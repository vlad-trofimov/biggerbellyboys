// Configuration
const CONFIG = {
    version: '3.1',
    // Restaurant data URL (JSON file generated by GitHub action)
    dataUrl: 'data/restaurants.json',
    
    // Default map center (will be updated based on restaurant locations)
    defaultCenter: [40.7128, -74.0060], // New York City
    defaultZoom: 10,
    
    // LocationIQ API configuration
    locationIQ: {
        apiKey: 'pk.20e7d474ebfc4866aad4494bb342ed89',
        region: 'us1' // us1 for US region, eu1 for Europe region
    }
};

// Global variables
let map;
let restaurants = [];
let markers = [];
let allTags = new Set();
let allReviewers = new Set();
let selectedTags = new Set();
// selectedReviewer removed - now using tags
let currentSort = 'newest';
let currentPage = 1;
let itemsPerPage = 12;
let totalFilteredRestaurants = 0;

// Debounce timer for rating slider
let ratingSliderDebounceTimer = null;

// Data variables
let restaurantData = null;

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    console.log(`üçî Bigger Belly Boys v${CONFIG.version} - Loading...`);
    // Clear any stale pending popup data on fresh page load
    window.pendingCountryPopup = null;
    initializeMap();
    setupEventListeners();
    setupBrowserNavigation();
    initializeFromUrl();
    loadRestaurantDataFromJSON();
    setupTabNavigation();
});

// Go to home page (clear all filters and URL parameters)
function goToHomePage() {
    // Clear all filters
    clearAllFilters();
    
    // Hide suggest form if shown
    hideSuggestFormFromUrl();
    
    // Remove all URL parameters and go to base URL
    window.history.pushState({}, '', window.location.pathname);
    
    // Reset to first page
    currentPage = 1;
    
    // Re-display all restaurants
    sortAndDisplayRestaurants();
}

// Load restaurant data from JSON file (generated by GitHub action)
async function loadRestaurantDataFromJSON() {
    const loadingElement = document.getElementById('loading');
    
    try {
        console.log('üìä Loading restaurant data from JSON...');
        const response = await fetch(`${CONFIG.dataUrl}?_t=${Date.now()}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log(`‚úÖ Loaded ${data.restaurants.length} restaurants from JSON (v${data.version})`);
        
        restaurants = data.restaurants;
        
        if (restaurants.length === 0) {
            throw new Error('No restaurants found in data');
        }
        
        // Populate global tag sets from loaded data
        populateTagSets();
        
        createMapMarkers();
        sortAndDisplayRestaurants();
        setupFilters();
        
        loadingElement.classList.add('hidden');
        console.log(`üéâ Application ready with ${restaurants.length} restaurants`);
        
    } catch (error) {
        console.error('‚ùå Error loading restaurant data:', error);
        loadingElement.innerHTML = `
            <div class="spinner" style="display: none;"></div>
            <p>Error loading restaurant data: ${error.message}</p>
            <p style="font-size: 0.9rem; margin-top: 1rem;">
                Please check your internet connection and try again.
            </p>
        `;
    }
}

// Populate global tag sets from restaurant data
function populateTagSets() {
    // Clear existing sets
    allTags.clear();
    allReviewers.clear();
    
    restaurants.forEach(restaurant => {
        // Add restaurant tags to global set
        if (restaurant.tags) {
            restaurant.tags.forEach(tag => allTags.add(tag));
        }
        
        // Add reviewer to global set
        if (restaurant.reviewer) {
            allReviewers.add(restaurant.reviewer);
        }
    });
}

// Initialize Leaflet map
function initializeMap() {
    map = L.map('map', {
        worldCopyJump: true,
        maxZoom: 20,
        minZoom: 2
    }).setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
    
    // Add CartoDB Positron tiles (clean, minimal style)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '¬© OpenStreetMap contributors ¬© CARTO',
        subdomains: 'abcd',
        maxZoom: 20
    }).addTo(map);
}

// Setup event listeners
function setupEventListeners() {
    // Filter toggle for mobile
    const filterToggle = document.getElementById('filter-toggle-btn');
    const filterContent = document.querySelector('.filter-content');
    
    filterToggle.addEventListener('click', function() {
        filterContent.classList.toggle('active');
    });
    
    // Clear filters button
    document.getElementById('clear-filters').addEventListener('click', clearAllFilters);
    
    // Tag search filter
    setupTagSearch();
    
    // Rating slider filter
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    
    ratingSlider.addEventListener('input', function() {
        const value = parseFloat(this.value);
        ratingValueDisplay.textContent = value === 0 ? '0+' : `${value}+`;
        currentPage = 1; // Reset to first page when rating changes
        
        // Clear existing timer
        if (ratingSliderDebounceTimer) {
            clearTimeout(ratingSliderDebounceTimer);
        }
        
        // Apply filters immediately (for instant visual feedback)
        applyFilters(true); // Skip URL update
        
        // Set new timer to update URL after user stops sliding
        ratingSliderDebounceTimer = setTimeout(() => {
            updateUrl(); // Update URL after 500ms delay
            ratingSliderDebounceTimer = null;
        }, 500);
    });
    
    // Sort filter
    document.getElementById('sort-filter').addEventListener('change', function() {
        currentSort = this.value;
        currentPage = 1; // Reset to first page when sorting changes
        updateUrl();
        sortAndDisplayRestaurants();
    });
}

// Initialize state from URL parameters
function initializeFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    
    // Get page from URL
    const pageParam = urlParams.get('page');
    if (pageParam) {
        const page = parseInt(pageParam);
        if (page > 0) {
            currentPage = page;
        }
    }
    
    // Get sort from URL
    const sortParam = urlParams.get('sort');
    if (sortParam && ['newest', 'oldest', 'rating-desc', 'rating-asc'].includes(sortParam)) {
        currentSort = sortParam;
        // Update the dropdown to match
        const sortDropdown = document.getElementById('sort-filter');
        if (sortDropdown) {
            sortDropdown.value = sortParam;
        }
    }
    
    // Get tags from URL
    const tagsParam = urlParams.get('tags');
    if (tagsParam) {
        selectedTags.clear();
        const tags = tagsParam.split(',').map(tag => tag.trim()).filter(tag => tag);
        tags.forEach(tag => selectedTags.add(tag));
        // Update display after DOM is ready
        setTimeout(() => updateSelectedTagsDisplay(), 0);
    }
    
    // Get rating from URL
    const ratingParam = urlParams.get('rating');
    if (ratingParam) {
        const rating = parseFloat(ratingParam);
        if (!isNaN(rating)) {
            const ratingSlider = document.getElementById('rating-filter');
            if (ratingSlider) {
                ratingSlider.value = rating.toString();
                const ratingValueDisplay = document.getElementById('rating-value');
                if (ratingValueDisplay) {
                    ratingValueDisplay.textContent = `${rating}+`;
                }
            }
        }
    }
    
    // Get suggest form state from URL
    const suggestParam = urlParams.get('suggest');
    if (suggestParam === 'true') {
        // Delay showing suggest form until after DOM is ready
        setTimeout(() => {
            showSuggestFormFromUrl();
        }, 0);
    }
    
    // Create initial history entry with current state
    const url = new URL(window.location);
    if (currentPage > 1) {
        url.searchParams.set('page', currentPage.toString());
    }
    if (currentSort !== 'newest') {
        url.searchParams.set('sort', currentSort);
    }
    if (selectedTags.size > 0) {
        url.searchParams.set('tags', Array.from(selectedTags).join(','));
    }
    if (ratingParam && !isNaN(parseFloat(ratingParam))) {
        url.searchParams.set('rating', ratingParam);
    }
    if (suggestParam === 'true') {
        url.searchParams.set('suggest', 'true');
    }
    window.history.replaceState({}, '', url);
}

// Initialize state from URL parameters (for navigation only - no history modification)
function initializeFromUrlForNavigation() {
    const urlParams = new URLSearchParams(window.location.search);
    
    // Get page from URL
    const pageParam = urlParams.get('page');
    if (pageParam) {
        const page = parseInt(pageParam);
        if (page > 0) {
            currentPage = page;
        }
    } else {
        currentPage = 1;
    }
    
    // Get suggest form state from URL
    const suggestParam = urlParams.get('suggest');
    if (suggestParam === 'true') {
        showSuggestFormFromUrl();
    } else {
        hideSuggestFormFromUrl();
    }
    
    // Get sort from URL
    const sortParam = urlParams.get('sort');
    if (sortParam && ['newest', 'oldest', 'rating-desc', 'rating-asc'].includes(sortParam)) {
        currentSort = sortParam;
        // Update the dropdown to match
        const sortDropdown = document.getElementById('sort-filter');
        if (sortDropdown) {
            sortDropdown.value = sortParam;
        }
    } else {
        currentSort = 'newest';
        const sortDropdown = document.getElementById('sort-filter');
        if (sortDropdown) {
            sortDropdown.value = 'newest';
        }
    }
    
    // Get tags from URL
    const tagsParam = urlParams.get('tags');
    selectedTags.clear();
    if (tagsParam) {
        const tags = tagsParam.split(',').map(tag => tag.trim()).filter(tag => tag);
        tags.forEach(tag => selectedTags.add(tag));
    }
    updateSelectedTagsDisplay();
    
    // Get rating from URL
    const ratingParam = urlParams.get('rating');
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    
    if (ratingParam && ratingSlider) {
        const rating = parseFloat(ratingParam);
        if (!isNaN(rating)) {
            ratingSlider.value = rating.toString();
            if (ratingValueDisplay) {
                ratingValueDisplay.textContent = `${rating}+`;
            }
        }
    } else if (ratingSlider) {
        // Reset to minimum if no rating param
        ratingSlider.value = ratingSlider.min;
        if (ratingValueDisplay) {
            ratingValueDisplay.textContent = `${ratingSlider.min}+`;
        }
    }
    
}

// Update URL with current state
function updateUrl() {
    const oldUrl = window.location.href;
    const url = new URL(window.location);
    
    // Set page parameter
    if (currentPage > 1) {
        url.searchParams.set('page', currentPage.toString());
    } else {
        url.searchParams.delete('page');
    }
    
    // Set sort parameter
    if (currentSort !== 'newest') {
        url.searchParams.set('sort', currentSort);
    } else {
        url.searchParams.delete('sort');
    }
    
    // Set tags parameter
    if (selectedTags.size > 0) {
        url.searchParams.set('tags', Array.from(selectedTags).join(','));
    } else {
        url.searchParams.delete('tags');
    }
    
    // Set rating parameter
    const ratingSlider = document.getElementById('rating-filter');
    if (ratingSlider) {
        const currentRating = parseFloat(ratingSlider.value);
        const minRating = parseFloat(ratingSlider.min);
        if (currentRating > minRating) {
            url.searchParams.set('rating', currentRating.toString());
        } else {
            url.searchParams.delete('rating');
        }
    }
    
    // Set suggest parameter (for suggest form state)
    const suggestTab = document.getElementById('suggest-tab');
    if (suggestTab && !suggestTab.classList.contains('hidden')) {
        url.searchParams.set('suggest', 'true');
    } else {
        url.searchParams.delete('suggest');
    }
    
    const newUrl = url.href;
    
    // Only push to history if the URL actually changed
    if (oldUrl !== newUrl) {
        window.history.pushState({}, '', url);
    }
}

// Setup browser navigation (back/forward buttons)
function setupBrowserNavigation() {
    window.addEventListener('popstate', function(event) {
        // Re-initialize from URL parameters when user navigates
        initializeFromUrlForNavigation();
        
        // If restaurants are already loaded, apply the URL state immediately
        if (restaurants.length > 0) {
            sortAndDisplayRestaurants();
            // Also apply filters to ensure everything is in sync (skip URL update to avoid creating new history)
            applyFilters(true);
        }
    });
}


// Extract TikTok video ID from URL
function extractTikTokVideoId(url) {
    if (!url) return null;
    const match = url.match(/\/video\/(\d+)/);
    return match ? match[1] : null;
}

// Get cached thumbnail path for a TikTok video
function getCachedThumbnailPath(tikTokVideoUrl) {
    const videoId = extractTikTokVideoId(tikTokVideoUrl);
    return videoId ? `thumbnails/${videoId}.jpeg` : null;
}

// Check if cached thumbnail actually exists
async function cachedThumbnailExists(thumbnailPath) {
    if (!thumbnailPath) return false;
    
    try {
        const response = await fetch(thumbnailPath, { method: 'HEAD' });
        return response.ok;
    } catch (error) {
        return false;
    }
}

// Location mapping and standardization system
const LOCATION_MAPPINGS = {
    // US States and territories
    'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California',
    'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia',
    'HI': 'Hawaii', 'ID': 'Idaho', 'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa',
    'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
    'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi', 'MO': 'Missouri',
    'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
    'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio',
    'OK': 'Oklahoma', 'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
    'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont',
    'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming',
    'PR': 'Puerto Rico', 'DC': 'District of Columbia',
    
    // Countries (common abbreviations)
    'MX': 'Mexico', 'JP': 'Japan', 'UK': 'United Kingdom', 'FR': 'France', 'DE': 'Germany',
    'IT': 'Italy', 'ES': 'Spain', 'AU': 'Australia', 'NZ': 'New Zealand', 'SG': 'Singapore',
    'TH': 'Thailand', 'PH': 'Philippines', 'KR': 'South Korea', 'TW': 'Taiwan', 'HK': 'Hong Kong'
};

// Parse location from Location column (not address)
function parseLocationData(locationString) {
    if (!locationString) return { city: '', region: '', fullLocation: '', searchableLocation: '' };
    
    // Parse "City, Region" format from Location column
    const parts = locationString.split(',').map(part => part.trim());
    
    if (parts.length >= 2) {
        const city = parts[0];
        const region = parts[1];
        
        // Get full region name for display (e.g., "PR" -> "Puerto Rico")
        const fullRegion = LOCATION_MAPPINGS[region.toUpperCase()] || region;
        
        // Create searchable location string (for filtering)
        const searchableLocation = `${city}, ${fullRegion}`.toLowerCase();
        
        return {
            city: city,
            region: region,
            fullRegion: fullRegion,
            fullLocation: `${city}, ${fullRegion}`,
            searchableLocation: searchableLocation,
            originalLocation: locationString,
            // Standardized versions for filtering
            cityStandardized: standardizeTag(city),
            fullRegionStandardized: standardizeTag(fullRegion),
            fullLocationStandardized: standardizeTag(`${city}, ${fullRegion}`)
        };
    }
    
    // Fallback for single location (just city)
    return {
        city: locationString,
        region: '',
        fullRegion: '',
        fullLocation: locationString,
        searchableLocation: locationString.toLowerCase(),
        originalLocation: locationString,
        // Standardized versions for filtering
        cityStandardized: standardizeTag(locationString),
        fullRegionStandardized: '',
        fullLocationStandardized: standardizeTag(locationString)
    };
}

// Extract city from address string (fallback only)
function extractCityFromAddress(address) {
    if (!address) return '';
    
    // Common address formats:
    // "123 Main St, New York, NY 10001"
    // "456 Oak Ave, Los Angeles, CA"
    // "789 Pine Rd, Chicago IL 60601"
    
    const parts = address.split(',').map(part => part.trim());
    
    if (parts.length >= 2) {
        // Second part is usually the city
        let city = parts[1].trim();
        
        // Remove state abbreviations and zip codes from city name
        city = city.replace(/\s+[A-Z]{2}(\s+\d{5})?$/i, '').trim();
        
        return city;
    }
    
    // Fallback: try to extract from single comma-separated format
    if (parts.length === 1) {
        const match = address.match(/,\s*([^,\d]+?)(?:\s+[A-Z]{2})?\s*\d*$/i);
        if (match) {
            return match[1].trim();
        }
    }
    
    return '';
}

// Format address with clickable location (city for filtering)
function formatAddressWithClickableLocation(address, locationData) {
    if (!locationData || !locationData.city) return address;
    
    const city = locationData.city;
    
    // Replace the city part in the address with a clickable span
    const cityRegex = new RegExp(`(,\\s*)(${city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(\\s*,|\\s+[A-Z]{2}|\\s*$)`, 'i');
    
    // Use the full display location (e.g., "San Juan, Puerto Rico") for the filter
    const filterLocation = locationData.fullLocation;
    
    return address.replace(cityRegex, (match, beforeCity, cityMatch, afterCity) => {
        return `${beforeCity}<span class="clickable-city" onclick="selectLocationTag(event, '${filterLocation}')" title="Filter by ${filterLocation}">${cityMatch}</span>${afterCity}`;
    });
}

// Legacy function for backwards compatibility
function formatAddressWithClickableCity(address, city) {
    if (!city) return address;
    
    // Replace the city part in the address with a clickable span
    const cityRegex = new RegExp(`(,\\s*)(${city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(\\s*,|\\s+[A-Z]{2}|\\s*$)`, 'i');
    
    return address.replace(cityRegex, (match, beforeCity, cityMatch, afterCity) => {
        return `${beforeCity}<span class="clickable-city" onclick="selectCityTag(event, '${city}')">${cityMatch}</span>${afterCity}`;
    });
}

// Get reviewer-specific rating icon with fallback
function getReviewerIcon(reviewer) {
    if (!reviewer) return 'src/vlad-bbb.png';
    
    const reviewerName = reviewer.toLowerCase().trim();
    switch (reviewerName) {
        case 'andrew':
            return 'src/andrew-bbb.png';
        case 'jason':
            return 'src/jason-bbb.png';
        default:
            return 'src/vlad-bbb.png';
    }
}

// Get rating icon with special case for 6.7
function getRatingIcon(rating, reviewer) {
    // Special case for 6.7 - use numeric image
    if (rating === 6.7) {
        return 'src/67.png';
    }
    
    // For all other ratings, use reviewer-specific icon
    return getReviewerIcon(reviewer);
}

// Standardize tag formatting (lowercase, trimmed)
function standardizeTag(tag) {
    return tag ? tag.toString().toLowerCase().trim() : '';
}

// Capitalize first letter for display purposes
function capitalizeForDisplay(text) {
    if (!text) return text;
    return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
}

// Generate Google Maps link from address and coordinates
function generateGoogleMapsLink(restaurant) {
    // If we have a manual Google Maps link, use it
    if (restaurant.googleMapsLink && restaurant.googleMapsLink.trim()) {
        return restaurant.googleMapsLink.trim();
    }
    
    // Generate search query with restaurant name and address
    const restaurantName = restaurant.restaurant || '';
    const address = restaurant.address || '';
    const searchQuery = `${restaurantName} ${address}`.trim();
    
    if (restaurant.latitude && restaurant.longitude && !isNaN(restaurant.latitude) && !isNaN(restaurant.longitude)) {
        // Use coordinates with restaurant name + address for better accuracy
        return `https://www.google.com/maps/search/${encodeURIComponent(searchQuery)}/@${restaurant.latitude},${restaurant.longitude},15z`;
    } else if (searchQuery) {
        // Fallback to restaurant name + address search
        return `https://www.google.com/maps/search/${encodeURIComponent(searchQuery)}`;
    }
    
    return null;
}


// Create map markers
function createMapMarkers() {
    restaurants.forEach((restaurant, index) => {
        const marker = L.marker([restaurant.latitude, restaurant.longitude])
            .addTo(map)
            .bindPopup(createPopupContent(restaurant));
        
        // Store reference to restaurant data
        marker.restaurantIndex = index;
        markers.push(marker);
    });
}

// Create popup content for map markers
function createPopupContent(restaurant) {
    const mapsLink = generateGoogleMapsLink(restaurant);
    
    return `
        <div class="popup-content">
            ${restaurant.tikTokThumbnail ? 
                `<img src="${restaurant.tikTokThumbnail}" alt="${restaurant.restaurant}" class="popup-thumbnail" onerror="this.src='${restaurant.tikTokThumbnailFallback}'; this.onerror=function(){this.style.display='none'}">` : 
                ''
            }
            <div class="popup-name">${restaurant.restaurant}</div>
            <div class="popup-location">üìç <span class="clickable-location" onclick="selectLocationTag(event, '${restaurant.locationData.fullLocation}')" title="Filter by ${restaurant.locationData.fullLocation}">${restaurant.locationData.fullLocation}</span></div>
            <div class="popup-address">${restaurant.address}</div>
            <div class="popup-rating">
                <span class="rating-value">${restaurant.rating.toFixed(1)}</span>
                <img src="${getRatingIcon(restaurant.rating, restaurant.reviewer)}" alt="Bigger Belly Rating ${restaurant.rating.toFixed(1)}" class="rating-icon" onerror="this.src='src/vlad-bbb.png'">
            </div>
            <div class="popup-links">
                ${restaurant.tikTokVideo ? 
                    `<a href="${restaurant.tikTokVideo}" target="_blank">Watch Review</a>` : 
                    ''
                }
                ${mapsLink ? 
                    `<a href="${mapsLink}" target="_blank">View on Maps</a>` : 
                    ''
                }
            </div>
            <div class="popup-reviewer">Reviewed by: <span class="clickable-reviewer" onclick="selectReviewer('${restaurant.reviewer}')">${capitalizeForDisplay(restaurant.reviewer)}</span></div>
        </div>
    `;
}

// Sort and display restaurants
function sortAndDisplayRestaurants() {
    // Sort restaurants based on current sort option
    let sortedRestaurants = [...restaurants];
    
    switch (currentSort) {
        case 'rating-asc':
            sortedRestaurants.sort((a, b) => a.rating - b.rating);
            break;
        case 'rating-desc':
            sortedRestaurants.sort((a, b) => b.rating - a.rating);
            break;
        case 'oldest':
            // Sort by date posted (oldest first)
            sortedRestaurants.sort((a, b) => {
                const dateA = a.datePosted ? new Date(a.datePosted) : new Date(0);
                const dateB = b.datePosted ? new Date(b.datePosted) : new Date(0);
                return dateA - dateB;
            });
            break;
        case 'newest':
        default:
            // Sort by date posted (newest first)
            sortedRestaurants.sort((a, b) => {
                const dateA = a.datePosted ? new Date(a.datePosted) : new Date(0);
                const dateB = b.datePosted ? new Date(b.datePosted) : new Date(0);
                return dateB - dateA;
            });
            break;
    }
    
    createRestaurantCards(sortedRestaurants);
    // Apply filters after creating new cards
    applyFilters();
}

// Create restaurant cards with pagination
function createRestaurantCards(sortedRestaurants = restaurants) {
    const restaurantList = document.getElementById('restaurant-list');
    restaurantList.innerHTML = '';
    
    // Store all sorted restaurants for filtering/pagination
    window.currentSortedRestaurants = sortedRestaurants;
    
    // Apply pagination - this will be updated by applyFilters
    displayPaginatedRestaurants(sortedRestaurants);
}

// Create a reusable restaurant card element
function createRestaurantCardElement(restaurant, includeClickEvent = true) {
    const originalIndex = restaurants.indexOf(restaurant);
    const card = document.createElement('div');
    card.className = 'restaurant-card';
    card.dataset.index = originalIndex;
    
    const tagsHtml = restaurant.tags.map(tag => `<span class="tag clickable-tag" onclick="event.stopPropagation(); selectTag('${tag}')">${tag}</span>`).join('');
    
    card.innerHTML = `
        ${restaurant.tikTokThumbnail ? 
            `<img src="${restaurant.tikTokThumbnail}" alt="${restaurant.restaurant}" class="restaurant-thumbnail" onerror="this.src='${restaurant.tikTokThumbnailFallback}'; this.onerror=function(){this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjE1MCIgdmlld0JveD0iMCAwIDMwMCAxNTAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMTUwIiBmaWxsPSIjRjBGMEYwIi8+Cjx0ZXh0IHg9IjE1MCIgeT0iNzUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTQiPk5vIEltYWdlPC90ZXh0Pgo8L3N2Zz4K'}">` : 
            `<div class="restaurant-thumbnail no-image" style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px; aspect-ratio: 1177 / 1570;">No Image</div>`
        }
        <div class="restaurant-info">
            <div class="restaurant-name">${restaurant.restaurant}</div>
            <div class="restaurant-location">üìç <span class="clickable-location" onclick="selectLocationTag(event, '${restaurant.locationData.fullLocation}')" title="Filter by ${restaurant.locationData.fullLocation}">${restaurant.locationData.fullLocation}</span></div>
            <div class="restaurant-address">${restaurant.address}</div>
            <div class="restaurant-rating">
                <span class="rating-value">${restaurant.rating.toFixed(1)}</span>
                <img src="${getRatingIcon(restaurant.rating, restaurant.reviewer)}" alt="Bigger Belly Rating ${restaurant.rating.toFixed(1)}" class="rating-icon" onerror="this.src='src/vlad-bbb.png'">
            </div>
            <div class="restaurant-tags">${tagsHtml}</div>
            <div class="restaurant-reviewer">Reviewed by: <span class="clickable-reviewer" onclick="event.stopPropagation(); selectReviewer('${restaurant.reviewer}')">${capitalizeForDisplay(restaurant.reviewer)}</span></div>
        </div>
    `;
    
    // Add click event to zoom to marker (only for main list, not popup)
    if (includeClickEvent) {
        card.addEventListener('click', () => {
            
            // Check if this is a global belly food tour restaurant
            const hasGlobalTourTag = restaurant.tags.some(tag => 
                standardizeTag(tag) === 'global belly food tour'
            );
            
            
            if (hasGlobalTourTag) {
                // Check if global belly food tour tag is currently selected
                const isGlobalTourSelected = selectedTags.has('global belly food tour');
                
                if (isGlobalTourSelected) {
                    // We're already on the global map, handle popup for country
                    const countryInfo = getCountryFromTags(restaurant.tags);
                    if (countryInfo) {
                            
                        // Pan map to country using dynamic coordinate lookup
                        if (globalMapInstance) {
                            console.log('Trying to get coordinates for country:', countryInfo.countryCode, countryInfo.country);
                            const coords = getCountryCoordinates(countryInfo.countryCode);
                            console.log('Got coordinates:', coords);
                            if (coords) {
                                // Close any existing popup immediately before panning
                                closeGlobalMapPopup();
                                
                                // Use proper 2D panning instead of 3D rotation
                                globalMapInstance.zoomToGeoPoint({
                                    latitude: coords[0], 
                                    longitude: coords[1]
                                }, 2.5, true);
                                
                                // Wait for animation to complete before showing popup
                                setTimeout(() => {
                                    showPopupAfterAnimation();
                                }, 1000); // 1 second delay for animation
                                return; // Don't show popup immediately
                            }
                        }
                        
                        // Map is already showing, open popup immediately (no animation needed)
                        showPopupAfterAnimation();
                        
                        function showPopupAfterAnimation() {
                        const globalTourRestaurants = restaurants.filter(r => {
                            const hasGBFTTag = r.tags.some(tag => 
                                standardizeTag(tag) === 'global belly food tour'
                            );
                            const rCountryInfo = getCountryFromTags(r.tags);
                            return hasGBFTTag && rCountryInfo && rCountryInfo.countryCode === countryInfo.countryCode;
                        }).map(r => {
                            const rCountryInfo = getCountryFromTags(r.tags);
                            return {
                                ...r,
                                country: rCountryInfo.country,
                                countryCode: rCountryInfo.countryCode
                            };
                        });
                        
                        const countryRestaurantsByCountry = {};
                        countryRestaurantsByCountry[countryInfo.countryCode] = globalTourRestaurants;
                        
                        // Position popup in center after map pans
                        const chartDiv = document.getElementById('world-map');
                        const chartRect = chartDiv ? chartDiv.getBoundingClientRect() : { width: 600, height: 400 };
                        const clickX = chartRect.width * 0.5; // Center horizontally  
                        const clickY = chartRect.height * 0.3; // Upper third
                        
                        // Show popup immediately
                        showGlobalMapPopup(countryInfo.countryCode, countryInfo.country, clickX, clickY, countryRestaurantsByCountry);
                        }
                    } else {
                        // Store for when map loads
                        window.pendingCountryPopup = countryInfo;
                    }
                } else {
                    // Global tour is not selected, treat as regular restaurant
                    const marker = markers[originalIndex];
                    if (marker) {
                        map.setView([restaurant.latitude, restaurant.longitude], 15);
                        marker.openPopup();
                    }
                }
            } else {
                // Regular restaurant - zoom to marker on local map
                const marker = markers[originalIndex];
                map.setView([restaurant.latitude, restaurant.longitude], 15);
                marker.openPopup();
            }
        });
    }
    
    return card;
}

// Display paginated restaurants
function displayPaginatedRestaurants(filteredRestaurants) {
    const restaurantList = document.getElementById('restaurant-list');
    restaurantList.innerHTML = '';
    
    // Update total for pagination
    totalFilteredRestaurants = filteredRestaurants.length;
    
    // Calculate pagination
    const totalPages = Math.ceil(totalFilteredRestaurants / itemsPerPage);
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, totalFilteredRestaurants);
    
    // Get restaurants for current page
    const restaurantsToShow = filteredRestaurants.slice(startIndex, endIndex);
    
    restaurantsToShow.forEach((restaurant, index) => {
        const card = createRestaurantCardElement(restaurant, true);
        restaurantList.appendChild(card);
    });
    
    // Update pagination controls
    updatePaginationControls();
    
    // Center map on first result when results change
    if (currentPage === 1) {
        centerMapOnFirstResult();
    }
}

// Update pagination controls
function updatePaginationControls() {
    const paginationContainer = document.getElementById('pagination');
    const totalPages = Math.ceil(totalFilteredRestaurants / itemsPerPage);
    
    if (totalPages <= 1) {
        paginationContainer.innerHTML = '';
        return;
    }
    
    let paginationHtml = '<div class="pagination">';
    
    // Previous button
    if (currentPage > 1) {
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(${currentPage - 1})">‚Üê Previous</button>`;
    }
    
    // Page numbers - show up to 5 page numbers
    const maxPagesToShow = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
    let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);
    
    // Adjust start page if we're near the end
    if (endPage - startPage + 1 < maxPagesToShow) {
        startPage = Math.max(1, endPage - maxPagesToShow + 1);
    }
    
    // Add first page and ellipsis if needed
    if (startPage > 1) {
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(1)">1</button>`;
        if (startPage > 2) {
            paginationHtml += '<span class="pagination-ellipsis">...</span>';
        }
    }
    
    // Add page numbers
    for (let i = startPage; i <= endPage; i++) {
        const activeClass = i === currentPage ? ' active' : '';
        paginationHtml += `<button class="pagination-btn${activeClass}" onclick="goToPage(${i})">${i}</button>`;
    }
    
    // Add last page and ellipsis if needed
    if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
            paginationHtml += '<span class="pagination-ellipsis">...</span>';
        }
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(${totalPages})">${totalPages}</button>`;
    }
    
    // Next button
    if (currentPage < totalPages) {
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(${currentPage + 1})">Next ‚Üí</button>`;
    }
    
    paginationHtml += '</div>';
    
    // Add results info
    const startResult = totalFilteredRestaurants === 0 ? 0 : (currentPage - 1) * itemsPerPage + 1;
    const endResult = Math.min(currentPage * itemsPerPage, totalFilteredRestaurants);
    paginationHtml += `<div class="pagination-info">Showing ${startResult}-${endResult} of ${totalFilteredRestaurants} restaurants</div>`;
    
    paginationContainer.innerHTML = paginationHtml;
}

// Navigate to a specific page
function goToPage(page) {
    const totalPages = Math.ceil(totalFilteredRestaurants / itemsPerPage);
    
    if (page >= 1 && page <= totalPages) {
        currentPage = page;
        updateUrl();
        
        // Get current filtered restaurants and display the correct page
        const filteredRestaurants = getFilteredRestaurants();
        displayPaginatedRestaurants(filteredRestaurants);
        
        // Scroll to top of restaurant list
        document.getElementById('restaurant-list').scrollIntoView({ behavior: 'smooth' });
    }
}

// Setup filter controls
function setupFilters() {
    setupDynamicRatingSlider();
}

// Setup dynamic rating slider based on actual data
function setupDynamicRatingSlider() {
    const ratings = restaurants.map(r => r.rating).filter(rating => rating > 0);
    
    if (ratings.length === 0) return;
    
    const minRating = Math.min(...ratings);
    const maxRating = Math.max(...ratings);
    
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    
    // Update slider attributes
    ratingSlider.min = minRating;
    ratingSlider.max = maxRating;
    ratingSlider.value = minRating;
    ratingSlider.step = '0.1';
    
    // Update display
    ratingValueDisplay.textContent = `${minRating}+`;
    
    // Update slider labels
    const sliderLabels = document.querySelector('.slider-labels');
    sliderLabels.innerHTML = `
        <span>${minRating}</span>
        <span id="rating-value">${minRating}+</span>
        <span>${maxRating}</span>
    `;
    
    // Re-attach the event listener for the updated slider with debounce
    ratingSlider.addEventListener('input', function() {
        const value = parseFloat(this.value);
        const newRatingValueDisplay = document.getElementById('rating-value');
        newRatingValueDisplay.textContent = `${value}+`;
        currentPage = 1; // Reset to first page when rating changes
        
        // Clear existing timer
        if (ratingSliderDebounceTimer) {
            clearTimeout(ratingSliderDebounceTimer);
        }
        
        // Apply filters immediately (for instant visual feedback)
        applyFilters(true); // Skip URL update
        
        // Set new timer to update URL after user stops sliding
        ratingSliderDebounceTimer = setTimeout(() => {
            updateUrl(); // Update URL after 500ms delay
            ratingSliderDebounceTimer = null;
        }, 500);
    });
    
}

// Setup tag search with autocomplete and multi-select
function setupTagSearch() {
    const tagInput = document.getElementById('tag-search');
    const suggestionsContainer = document.getElementById('tag-suggestions');
    const selectedTagsContainer = document.getElementById('selected-tags');
    
    tagInput.addEventListener('input', function() {
        const query = this.value.toLowerCase().trim();
        
        if (query.length === 0) {
            suggestionsContainer.classList.add('hidden');
            return;
        }
        
        // Get tags from restaurants that match current filters
        const currentRating = parseFloat(document.getElementById('rating-filter').value) || 0;
        
        const availableTagsFromFilteredRestaurants = new Set();
        restaurants.forEach(restaurant => {
            // Check if restaurant matches current selected tags and rating
            let matchesSelectedTags = true;
            if (selectedTags.size > 0) {
                matchesSelectedTags = Array.from(selectedTags).every(selectedTag => {
                    const standardizedSelectedTag = standardizeTag(selectedTag);
                    
                    // Check if it matches a regular tag (already standardized)
                    const matchesTag = restaurant.tags.some(restaurantTag => 
                        restaurantTag === standardizedSelectedTag
                    );
                    // Or check if it matches the reviewer (already standardized)
                    const matchesReviewer = restaurant.reviewer === standardizedSelectedTag;
                    // Or check if it matches location data (only city name)
                    const matchesLocation = restaurant.locationData && 
                                          restaurant.locationData.cityStandardized === standardizedSelectedTag;
                    
                    return matchesTag || matchesReviewer || matchesLocation;
                });
            }
            
            const matchesRating = restaurant.rating >= currentRating;
            
            if (matchesSelectedTags && matchesRating) {
                // Add regular tags (already standardized during processing)
                restaurant.tags.forEach(tag => availableTagsFromFilteredRestaurants.add(tag));
                // Add this restaurant's reviewer as available tag (already standardized)
                if (restaurant.reviewer) {
                    availableTagsFromFilteredRestaurants.add(restaurant.reviewer);
                }
                // Add location-based tags (only city name)
                if (restaurant.locationData && restaurant.locationData.cityStandardized) {
                    availableTagsFromFilteredRestaurants.add(restaurant.locationData.cityStandardized);
                }
            }
        });
        
        // Filter available tags based on input and current filters
        const availableTags = Array.from(availableTagsFromFilteredRestaurants).filter(tag => {
            return tag.toLowerCase().includes(query) && !selectedTags.has(tag);
        });
        
        if (availableTags.length === 0) {
            suggestionsContainer.classList.add('hidden');
            return;
        }
        
        // Show suggestions
        suggestionsContainer.innerHTML = '';
        availableTags.slice(0, 8).forEach(tag => { // Limit to 8 suggestions
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'tag-suggestion-item';
            suggestionItem.textContent = tag;
            suggestionItem.addEventListener('click', () => selectTag(tag));
            suggestionsContainer.appendChild(suggestionItem);
        });
        
        suggestionsContainer.classList.remove('hidden');
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener('click', function(e) {
        if (!tagInput.contains(e.target) && !suggestionsContainer.contains(e.target)) {
            suggestionsContainer.classList.add('hidden');
        }
    });
    
    // Handle Enter key to select first suggestion
    tagInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            const firstSuggestion = suggestionsContainer.querySelector('.tag-suggestion-item');
            if (firstSuggestion) {
                selectTag(firstSuggestion.textContent);
            }
        }
    });
}

function selectTag(tag) {
    const standardizedTag = standardizeTag(tag);
    
    // Don't add if already selected (check standardized version)
    if (Array.from(selectedTags).some(selectedTag => standardizeTag(selectedTag) === standardizedTag)) {
        return;
    }
    
    selectedTags.add(standardizedTag);
    updateSelectedTagsDisplay();
    
    // Clear input and hide suggestions
    document.getElementById('tag-search').value = '';
    document.getElementById('tag-suggestions').classList.add('hidden');
    
    // Auto-expand filters on mobile when tag is selected
    expandFiltersOnMobile();
    
    // Reset to first page when tag is selected
    currentPage = 1;
    updateUrl();
    
    // Clear any pending popup when selecting tags (we want clean global map)
    if (standardizedTag === 'global belly food tour') {
        window.pendingCountryPopup = null;
    }
    
    applyFilters();
    
    // Scroll to top of page when tag is selected
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Select city tag with event handling (prevents card click zooming)
function selectCityTag(event, city) {
    // Prevent event from bubbling up to the restaurant card click handler
    event.stopPropagation();
    
    // Use the regular selectTag function for the filtering logic
    selectTag(city);
}

// Select location tag with event handling (prevents card click zooming)
function selectLocationTag(event, location) {
    // Prevent event from bubbling up to the restaurant card click handler
    event.stopPropagation();
    
    // Extract city name from full location (everything before the first comma)
    const cityName = location.split(',')[0].trim();
    
    // Use the regular selectTag function with just the city name
    selectTag(cityName);
}

// Auto-expand filters on mobile when interaction happens
function expandFiltersOnMobile() {
    // Check if we're on mobile (filter toggle is visible)
    const filterToggle = document.getElementById('filter-toggle-btn');
    if (filterToggle && window.getComputedStyle(filterToggle).display !== 'none') {
        const filterContent = document.querySelector('.filter-content');
        if (filterContent && !filterContent.classList.contains('active')) {
            filterContent.classList.add('active');
        }
    }
}

function removeTag(tag) {
    selectedTags.delete(tag);
    updateSelectedTagsDisplay();
    
    // Reset to first page when tag is removed
    currentPage = 1;
    updateUrl();
    
    applyFilters();
}

function selectReviewer(reviewer) {
    // Auto-expand filters on mobile when reviewer is selected
    expandFiltersOnMobile();
    // Now just use the existing tag selection system
    selectTag(reviewer);
}

function updateSelectedTagsDisplay() {
    const container = document.getElementById('selected-tags');
    container.innerHTML = '';
    
    selectedTags.forEach(tag => {
        const tagElement = document.createElement('div');
        tagElement.className = 'selected-tag';
        tagElement.innerHTML = `
            <span>${tag}</span>
            <button class="remove-tag" onclick="removeTag('${tag}')">&times;</button>
        `;
        container.appendChild(tagElement);
    });
}

// These functions are no longer needed with the new filter design

// Get filtered restaurants based on current filters
function getFilteredRestaurants() {
    const minRating = parseFloat(document.getElementById('rating-filter').value) || 0;
    const sortedRestaurants = window.currentSortedRestaurants || restaurants;
    
    return sortedRestaurants.filter(restaurant => {
        let show = true;
        
        // Filter by selected tags (must have ALL selected tags - includes reviewers)
        if (selectedTags.size > 0) {
            const hasAllSelectedTags = Array.from(selectedTags).every(selectedTag => {
                const standardizedSelectedTag = standardizeTag(selectedTag);
                
                // Check if it matches a regular tag (already standardized)
                const matchesTag = restaurant.tags.some(restaurantTag => 
                    restaurantTag === standardizedSelectedTag
                );
                // Or check if it matches the reviewer (already standardized)
                const matchesReviewer = restaurant.reviewer === standardizedSelectedTag;
                // Or check if it matches location data (only city name)
                const matchesLocation = restaurant.locationData && 
                                      restaurant.locationData.cityStandardized === standardizedSelectedTag;
                
                return matchesTag || matchesReviewer || matchesLocation;
            });
            if (!hasAllSelectedTags) show = false;
        }
        
        // Filter by rating
        if (restaurant.rating < minRating) show = false;
        
        return show;
    });
}

// Apply filters with pagination
function applyFilters(skipUrlUpdate = false) {
    // Reset to first page when filters change (but not during navigation)
    if (!skipUrlUpdate) {
        currentPage = 1;
        updateUrl();
    }
    
    // Get filtered restaurants
    const filteredRestaurants = getFilteredRestaurants();
    
    // Update map markers visibility
    restaurants.forEach((restaurant, index) => {
        const marker = markers[index];
        const isFiltered = filteredRestaurants.includes(restaurant);
        
        if (isFiltered) {
            if (!map.hasLayer(marker)) {
                map.addLayer(marker);
            }
        } else {
            if (map.hasLayer(marker)) {
                map.removeLayer(marker);
            }
        }
    });
    
    // Display paginated filtered restaurants
    displayPaginatedRestaurants(filteredRestaurants);
    
    // Update global map visibility and highlighting
    updateGlobalMap();
}

// Clear all filters
function clearAllFilters() {
    // Clear selected tags
    selectedTags.clear();
    updateSelectedTagsDisplay();
    
    // Clear tag search input
    document.getElementById('tag-search').value = '';
    document.getElementById('tag-suggestions').classList.add('hidden');
    
    // Reset rating slider to minimum value
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    ratingSlider.value = ratingSlider.min;
    ratingValueDisplay.textContent = `${ratingSlider.min}+`;
    
    // Reset sort to default
    currentSort = 'newest';
    document.getElementById('sort-filter').value = 'newest';
    
    // Reset pagination
    currentPage = 1;
    updateUrl();
    
    // Re-sort and display all restaurants
    sortAndDisplayRestaurants();
}

// Center map to show all restaurants with appropriate bounding box
function centerMapOnCenterOfMass() {
    if (restaurants.length === 0) return;
    
    // Find bounding box of all restaurant locations
    let minLat = Infinity;
    let maxLat = -Infinity;
    let minLng = Infinity;
    let maxLng = -Infinity;
    let count = 0;
    
    restaurants.forEach(restaurant => {
        if (restaurant.latitude && restaurant.longitude) {
            minLat = Math.min(minLat, restaurant.latitude);
            maxLat = Math.max(maxLat, restaurant.latitude);
            minLng = Math.min(minLng, restaurant.longitude);
            maxLng = Math.max(maxLng, restaurant.longitude);
            count++;
        }
    });
    
    if (count > 0) {
        // Create bounding box with some padding
        const bounds = [
            [minLat, minLng],
            [maxLat, maxLng]
        ];
        
        // Fit map to show all restaurants with padding
        map.fitBounds(bounds, {
            padding: [20, 20], // Add 20px padding on all sides
            maxZoom: 12 // Don't zoom in too close even if restaurants are clustered
        });
        
    } else {
        // Fallback to NYC if no valid coordinates
        map.setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
    }
}

// Center map on first filtered result with city-level zoom
function centerMapOnFirstResult() {
    const filteredRestaurants = getFilteredRestaurants();
    
    if (filteredRestaurants.length === 0) {
        // Fallback to showing all restaurants if no filtered results
        centerMapOnCenterOfMass();
        return;
    }
    
    const firstRestaurant = filteredRestaurants[0];
    if (firstRestaurant.latitude && firstRestaurant.longitude) {
        // Center on first result with city-level zoom (zoom 10-11 shows city + surrounding areas)
        map.setView([firstRestaurant.latitude, firstRestaurant.longitude], 11);
    } else {
        // Fallback to NYC if no valid coordinates
        map.setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
    }
}

// Center map on all restaurants (fallback function)
function centerMapOnRestaurants() {
    if (restaurants.length === 0) return;
    
    const group = new L.featureGroup(markers);
    map.fitBounds(group.getBounds().pad(0.1));
}

// Tab Navigation Setup
function setupTabNavigation() {
    const tabBtns = document.querySelectorAll('.tab-btn');
    
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });
    
    // Set up restaurant form if suggest tab exists
    setupRestaurantForm();
    setupSocialMediaValidation();
}

function switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
    });
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('hidden', content.id !== `${tabName}-tab`);
    });
    
    // Load required scripts if switching to suggest tab
    if (tabName === 'suggest') {
        setupPlaceSearch();
        loadRecaptcha();
    }
}

function loadRecaptcha() {
    // Check if reCAPTCHA script is already loaded
    if (window.grecaptcha) {
        document.getElementById('recaptcha-container').style.display = 'block';
        return;
    }
    
    // Load reCAPTCHA script
    const script = document.createElement('script');
    script.src = 'https://www.google.com/recaptcha/api.js';
    script.async = true;
    script.defer = true;
    script.onload = () => {
        document.getElementById('recaptcha-container').style.display = 'block';
    };
    document.head.appendChild(script);
}

// OpenStreetMap Place Search Setup
function setupPlaceSearch() {
    const searchInput = document.getElementById('restaurantSearch');
    const searchResults = document.getElementById('searchResults');
    
    if (!searchInput || !searchResults) return;
    
    let searchTimeout;
    
    // Setup search input event listener
    searchInput.addEventListener('input', function(e) {
        const query = e.target.value.trim();
        const clearBtn = document.getElementById('clearSearchBtn');
        
        // Show/hide clear button based on content
        if (clearBtn) {
            if (query.length > 0) {
                clearBtn.classList.remove('hidden');
            } else {
                clearBtn.classList.add('hidden');
            }
        }
        
        // Clear previous timeout
        clearTimeout(searchTimeout);
        
        if (query.length < 3) {
            hideSearchResults();
            return;
        }
        
        // Optimized debounce for faster response
        searchTimeout = setTimeout(() => {
            searchPlaces(query);
        }, 200); // Reduced from 300ms to 200ms for faster response
    });
    
    // Hide results when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            hideSearchResults();
        }
    });
    
    // Setup social media functionality
    setupSocialMediaForm();
}

// Setup social media platform and username functionality
function setupSocialMediaForm() {
    const platformSelect = document.getElementById('socialPlatform');
    const usernameInput = document.getElementById('socialUsername');
    const usernamePrefix = document.getElementById('usernamePrefix');
    const hiddenUrlInput = document.getElementById('socialMediaUrl');
    
    if (!platformSelect || !usernameInput || !usernamePrefix || !hiddenUrlInput) return;
    
    // Platform selection handler
    platformSelect.addEventListener('change', function() {
        updateUsernamePrefix();
        generateSocialMediaUrl();
    });
    
    // Username input handler
    usernameInput.addEventListener('input', function() {
        generateSocialMediaUrl();
        validateSocialMediaForm();
    });
    
    function updateUsernamePrefix() {
        const platform = platformSelect.value;
        
        switch(platform) {
            case 'instagram':
                usernamePrefix.textContent = '@';
                usernamePrefix.classList.remove('hidden');
                usernameInput.placeholder = 'username';
                usernameInput.disabled = false;
                break;
            case 'tiktok':
                usernamePrefix.textContent = '@';
                usernamePrefix.classList.remove('hidden');
                usernameInput.placeholder = 'username';
                usernameInput.disabled = false;
                break;
            case 'youtube':
                usernamePrefix.textContent = '@';
                usernamePrefix.classList.remove('hidden');
                usernameInput.placeholder = 'channelname';
                usernameInput.disabled = false;
                break;
            default:
                usernamePrefix.classList.add('hidden');
                usernameInput.placeholder = '';
                usernameInput.disabled = true;
                usernameInput.value = '';
        }
    }
    
    function generateSocialMediaUrl() {
        const platform = platformSelect.value;
        const username = usernameInput.value.trim();
        
        if (!platform || !username) {
            hiddenUrlInput.value = '';
            return;
        }
        
        let url = '';
        const cleanUsername = username.replace(/^[@]/, ''); // Remove @ if user typed it
        
        switch(platform) {
            case 'instagram':
                url = `https://instagram.com/${cleanUsername}`;
                break;
            case 'tiktok':
                url = `https://tiktok.com/@${cleanUsername}`;
                break;
            case 'youtube':
                // Handle both @handle and channel formats
                if (cleanUsername.startsWith('@') || !cleanUsername.includes('/')) {
                    url = `https://youtube.com/@${cleanUsername}`;
                } else {
                    url = `https://youtube.com/${cleanUsername}`;
                }
                break;
        }
        
        hiddenUrlInput.value = url;
    }
    
    function validateSocialMediaForm() {
        const platform = platformSelect.value;
        const username = usernameInput.value.trim();
        const url = hiddenUrlInput.value;
        
        // Remove previous validation classes
        platformSelect.classList.remove('valid', 'invalid');
        usernameInput.classList.remove('valid', 'invalid');
        
        if (platform && username && url) {
            if (validateSocialMediaUrl(url)) {
                platformSelect.classList.add('valid');
                usernameInput.classList.add('valid');
            } else {
                usernameInput.classList.add('invalid');
            }
        }
    }
    
    // Initialize prefix state
    updateUsernamePrefix();
}

// Convert Photon API response format to Nominatim-compatible format
function convertPhotonToNominatim(feature) {
    const props = feature.properties || {};
    const coords = feature.geometry?.coordinates || [0, 0];
    
    // Build address components
    const address = {
        house_number: props.housenumber || '',
        road: props.street || '',
        city: props.city || '',
        state: props.state || '',
        postcode: props.postcode || '',
        country: props.country || 'United States',
        country_code: 'us'
    };
    
    // Build display name
    const nameParts = [
        props.name,
        props.housenumber,
        props.street,
        props.city,
        props.state,
        props.postcode,
        'United States'
    ].filter(Boolean);
    
    return {
        place_id: feature.properties.osm_id || Math.random(),
        lat: coords[1]?.toString() || '0',
        lon: coords[0]?.toString() || '0', 
        display_name: nameParts.join(', '),
        type: props.osm_value || 'restaurant',
        class: props.osm_key || 'amenity',
        category: 'amenity',
        address: address,
        extratags: {
            amenity: props.osm_value || 'restaurant',
            name: props.name || ''
        }
    };
}

// Minimal search query variations for maximum speed
function prepareSearchQueries(originalQuery) {
    const queries = [];
    const query = originalQuery.trim().toLowerCase();
    
    // 1. Always try original query first
    queries.push(originalQuery);
    
    // 2. Only ONE fallback: add "restaurant" if query is short and doesn't contain restaurant words
    if (query.length <= 20 && !query.includes('restaurant') && !query.includes('cafe') && !query.includes('bar')) {
        queries.push(`${originalQuery} restaurant`);
    }
    
    return queries.slice(0, 2); // Maximum 2 queries for speed
}

// Remove duplicate search results
function removeDuplicateResults(results) {
    const seen = new Set();
    return results.filter(place => {
        const key = `${place.display_name}-${place.lat}-${place.lon}`;
        if (seen.has(key)) {
            return false;
        }
        seen.add(key);
        return true;
    });
}

async function searchPlaces(query) {
    const searchResults = document.getElementById('searchResults');
    
    try {
        // Show loading state
        searchResults.innerHTML = '<div class="search-loading">Searching...</div>';
        searchResults.classList.remove('hidden');
        
        // Get LocationIQ API configuration
        const LOCATIONIQ_API_KEY = CONFIG.locationIQ.apiKey;
        const LOCATIONIQ_REGION = CONFIG.locationIQ.region;
        let allResults = [];
        
        // Primary search using LocationIQ Autocomplete API
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            
            const autocompleteResponse = await fetch(
                `https://${LOCATIONIQ_REGION}.locationiq.com/v1/autocomplete?` + new URLSearchParams({
                    key: LOCATIONIQ_API_KEY,
                    q: query,
                    limit: '10',
                    countrycodes: 'us' // Focus on US results
                }), {
                    signal: controller.signal
                }
            );
            
            clearTimeout(timeoutId);
            
            if (autocompleteResponse.ok) {
                const autocompleteData = await autocompleteResponse.json();
                
                // Transform LocationIQ results to match expected format
                const transformedResults = autocompleteData.map(place => ({
                    place_id: place.place_id || Math.random(),
                    lat: place.lat,
                    lon: place.lon,
                    display_name: place.display_place || place.display_name,
                    type: 'place',
                    class: 'place',
                    category: 'place',
                    address: place.display_address || '',
                    full_address: place.display_address || place.display_name,
                    extratags: {
                        name: place.display_place || ''
                    }
                }));
                
                allResults = transformedResults;
            }
        } catch (error) {
            console.log('LocationIQ autocomplete search failed:', error.message);
        }
        
        // Remove duplicates based on display_name and coordinates
        const uniqueResults = removeDuplicateResults(allResults);
        
        // Filter and validate results
        const validResults = uniqueResults.filter(place => {
            return place.display_name && place.lat && place.lon;
        });
        
        displaySearchResults(validResults.slice(0, 8));
        
    } catch (error) {
        console.error('Search error:', error);
        searchResults.innerHTML = '<div class="search-no-results">Search failed. Please try again.</div>';
    }
}

function displaySearchResults(results) {
    const searchResults = document.getElementById('searchResults');
    
    if (results.length === 0) {
        searchResults.innerHTML = '<div class="search-no-results">No restaurants found. Try a different search term.</div>';
        return;
    }
    
    const resultsHTML = results.map(place => {
        const name = place.display_name || extractPlaceName(place);
        const address = place.address || '';
        const type = getPlaceType(place);
        
        return `
            <div class="search-result-item" onclick="selectPlace(${JSON.stringify(place).replace(/"/g, '&quot;')})">
                <div class="search-result-name">${escapeHtml(name)}</div>
                ${address ? `<div class="search-result-address">${escapeHtml(address)}</div>` : ''}
                ${type ? `<div class="search-result-type">${escapeHtml(type)}</div>` : ''}
            </div>
        `;
    }).join('');
    
    searchResults.innerHTML = resultsHTML;
}

function extractPlaceName(place) {
    // Try to get a clean restaurant name from the display_name
    if (place.name) {
        return place.name;
    }
    
    // Fallback: extract first part of display_name before first comma
    const displayName = place.display_name || '';
    const firstPart = displayName.split(',')[0];
    return firstPart || 'Unknown Restaurant';
}

function getPlaceType(place) {
    const type = place.type || '';
    const amenity = place.extratags?.amenity || '';
    
    if (amenity) return amenity.replace('_', ' ');
    if (type) return type.replace('_', ' ');
    return '';
}

function selectPlace(place) {
    console.log('Place selected:', place);
    
    // Extract name and address properly
    const name = place.display_name || extractPlaceName(place);
    const address = place.address || place.full_address || '';
    
    // Populate form fields
    document.getElementById('restaurantName').value = name;
    document.getElementById('address').value = address;
    document.getElementById('latitude').value = place.lat || '';
    document.getElementById('longitude').value = place.lon || '';
    
    // Clear search and hide results
    document.getElementById('restaurantSearch').value = name;
    hideSearchResults();
    
    // Show clear button since we now have content
    const clearBtn = document.getElementById('clearSearchBtn');
    if (clearBtn) {
        clearBtn.classList.remove('hidden');
    }
    
    // Validate form
    validateForm();
}

function hideSearchResults() {
    const searchResults = document.getElementById('searchResults');
    if (searchResults) {
        searchResults.classList.add('hidden');
    }
}

function clearRestaurantSearch() {
    // Clear search input
    const searchInput = document.getElementById('restaurantSearch');
    if (searchInput) {
        searchInput.value = '';
    }
    
    
    // Clear auto-populated fields
    document.getElementById('restaurantName').value = '';
    document.getElementById('address').value = '';
    document.getElementById('latitude').value = '';
    document.getElementById('longitude').value = '';
    
    // Hide search results and clear button
    hideSearchResults();
    const clearBtn = document.getElementById('clearSearchBtn');
    if (clearBtn) {
        clearBtn.classList.add('hidden');
    }
    
    // Validate form (will likely show required field errors)
    validateForm();
    
    // Focus back to search input
    if (searchInput) {
        searchInput.focus();
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}


function validateForm() {
    const requiredFields = ['restaurantName', 'address', 'submitterName', 'socialPlatform', 'socialUsername'];
    let allValid = true;
    let errors = [];
    
    // Check required fields
    requiredFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (!field || !field.value.trim()) {
            allValid = false;
            const fieldName = field ? field.labels[0].textContent.replace(' *', '') : fieldId;
            errors.push(`${fieldName} is required`);
        }
    });
    
    
    // Validate social media URL with regex
    const socialMediaUrl = document.getElementById('socialMediaUrl').value.trim();
    if (socialMediaUrl && !validateSocialMediaUrl(socialMediaUrl)) {
        allValid = false;
        errors.push('Please provide a valid Instagram, TikTok, or YouTube profile URL');
    }
    
    // Update submit button state
    const submitBtn = document.getElementById('submitBtn');
    if (submitBtn) {
        submitBtn.disabled = !allValid;
    }
    
    // Show validation errors (optional)
    if (errors.length > 0) {
        console.log('Validation errors:', errors);
    }
    
    return allValid;
}

function validateSocialMediaUrl(url) {
    // Only allow Instagram, TikTok, and YouTube
    const patterns = {
        instagram: /^https?:\/\/(www\.)?instagram\.com\/[a-zA-Z0-9._]+\/?$/,
        tiktok: /^https?:\/\/(www\.)?tiktok\.com\/@[a-zA-Z0-9._]+\/?$/,
        youtube: /^https?:\/\/(www\.)?youtube\.com\/(channel\/[a-zA-Z0-9_-]+|c\/[a-zA-Z0-9_-]+|user\/[a-zA-Z0-9_-]+|@[a-zA-Z0-9._-]+)\/?$/
    };
    
    // Check if URL matches any of the allowed patterns
    return Object.values(patterns).some(pattern => pattern.test(url));
}

function setupSocialMediaValidation() {
    const socialMediaInput = document.getElementById('socialMediaUrl');
    if (!socialMediaInput) return;
    
    // Add real-time validation
    socialMediaInput.addEventListener('input', function(e) {
        const url = e.target.value.trim();
        const field = e.target;
        
        // Remove previous validation classes
        field.classList.remove('valid', 'invalid');
        
        if (url) {
            if (validateSocialMediaUrl(url)) {
                field.classList.add('valid');
            } else {
                field.classList.add('invalid');
            }
        }
        
        // Revalidate form
        validateForm();
    });
}

// Restaurant Form Setup
function setupRestaurantForm() {
    const form = document.getElementById('restaurantForm');
    if (!form) return;
    
    const WORKER_URL = 'https://restaurant-form-handler.vlad-trofimov.workers.dev';
    
    form.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const submitBtn = document.getElementById('submitBtn');
        const result = document.getElementById('result');
        
        // Disable button and show loading
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';
        result.style.display = 'none';
        
        try {
            // Validate form before submission
            if (!validateForm()) {
                throw new Error('Please fill in all required fields correctly');
            }
            
            // Ensure social media URL is generated
            const platformSelect = document.getElementById('socialPlatform');
            const usernameInput = document.getElementById('socialUsername');
            if (platformSelect && usernameInput && platformSelect.value && usernameInput.value) {
                // Trigger URL generation one more time to be safe
                const event = new Event('input', { bubbles: true });
                usernameInput.dispatchEvent(event);
            }
            
            // Get form data
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            // Get reCAPTCHA token
            if (window.grecaptcha) {
                const recaptchaResponse = grecaptcha.getResponse();
                if (!recaptchaResponse) {
                    throw new Error('Please complete the reCAPTCHA verification');
                }
                data.recaptchaToken = recaptchaResponse;
            } else {
                throw new Error('reCAPTCHA not loaded. Please try again.');
            }
            
            // Remove empty honeypot field if present
            delete data.website;
            
            console.log('Submitting restaurant suggestion:', data);
            
            // Submit to worker
            const response = await fetch(WORKER_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            console.log('Response status:', response.status);
            const responseData = await response.json();
            console.log('Response data:', responseData);
            
            if (responseData.success) {
                result.className = 'result success';
                result.textContent = responseData.message || 'Restaurant submitted successfully! Thank you for your suggestion.';
                e.target.reset(); // Clear form
                if (window.grecaptcha) {
                    grecaptcha.reset(); // Reset reCAPTCHA
                }
            } else {
                throw new Error(responseData.error || 'Submission failed');
            }
            
        } catch (error) {
            console.error('Submission error:', error);
            result.className = 'result error';
            result.textContent = 'Error: ' + error.message;
        }
        
        // Re-enable button and show result
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Restaurant Suggestion';
        result.style.display = 'block';
    });
}

// Debug function to show tab navigation (remove after testing)
function showTabs() {
    const tabNav = document.querySelector('.tab-navigation');
    if (tabNav) {
        tabNav.style.display = 'flex';
        console.log('‚úÖ Tab navigation is now visible');
    } else {
        console.log('‚ùå Tab navigation not found');
    }
}

// Function to show the suggest form (called by header button)
function showSuggestForm() {
    // Hide restaurants content and show suggest form
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.add('hidden');
        suggestTab.classList.remove('hidden');
        
        // Load required scripts for the form
        setupPlaceSearch();
        loadRecaptcha();
        
        // Scroll to top of form
        suggestTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        // Update URL to include suggest parameter
        updateUrl();
        
        console.log('‚úÖ Opened restaurant suggestion form');
    }
}

// Function to show suggest form from URL (no scrolling)
function showSuggestFormFromUrl() {
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.add('hidden');
        suggestTab.classList.remove('hidden');
        
        // Load required scripts for the form
        setupPlaceSearch();
        loadRecaptcha();
        
        console.log('‚úÖ Showed restaurant suggestion form from URL');
    }
}

// Function to hide the suggest form and return to restaurants
function hideSuggestForm() {
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.remove('hidden');
        suggestTab.classList.add('hidden');
        
        // Update URL to remove suggest parameter
        updateUrl();
        
        console.log('‚úÖ Closed restaurant suggestion form');
    }
}

// Function to hide suggest form from URL navigation (no URL update)
function hideSuggestFormFromUrl() {
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.remove('hidden');
        suggestTab.classList.add('hidden');
        
    }
}

// Debug function to switch to suggest tab (keep for console access)
function showSuggestTab() {
    showSuggestForm();
}

// Comprehensive country name to country code mapping for Global Belly Food Tour
const countryMapping = {
    'afghanistan': { country: 'Afghanistan', countryCode: 'AF' },
    'albania': { country: 'Albania', countryCode: 'AL' },
    'algeria': { country: 'Algeria', countryCode: 'DZ' },
    'argentina': { country: 'Argentina', countryCode: 'AR' },
    'armenia': { country: 'Armenia', countryCode: 'AM' },
    'australia': { country: 'Australia', countryCode: 'AU' },
    'austria': { country: 'Austria', countryCode: 'AT' },
    'azerbaijan': { country: 'Azerbaijan', countryCode: 'AZ' },
    'bangladesh': { country: 'Bangladesh', countryCode: 'BD' },
    'belgium': { country: 'Belgium', countryCode: 'BE' },
    'brazil': { country: 'Brazil', countryCode: 'BR' },
    'bulgaria': { country: 'Bulgaria', countryCode: 'BG' },
    'cambodia': { country: 'Cambodia', countryCode: 'KH' },
    'canada': { country: 'Canada', countryCode: 'CA' },
    'chile': { country: 'Chile', countryCode: 'CL' },
    'china': { country: 'China', countryCode: 'CN' },
    'colombia': { country: 'Colombia', countryCode: 'CO' },
    'cuba': { country: 'Cuba', countryCode: 'CU' },
    'czech republic': { country: 'Czech Republic', countryCode: 'CZ' },
    'denmark': { country: 'Denmark', countryCode: 'DK' },
    'dominica': { country: 'Dominica', countryCode: 'DM' },
    'ecuador': { country: 'Ecuador', countryCode: 'EC' },
    'egypt': { country: 'Egypt', countryCode: 'EG' },
    'eritrea': { country: 'Eritrea', countryCode: 'ER' },
    'estonia': { country: 'Estonia', countryCode: 'EE' },
    'ethiopia': { country: 'Ethiopia', countryCode: 'ET' },
    'finland': { country: 'Finland', countryCode: 'FI' },
    'france': { country: 'France', countryCode: 'FR' },
    'georgia': { country: 'Georgia', countryCode: 'GE' },
    'germany': { country: 'Germany', countryCode: 'DE' },
    'ghana': { country: 'Ghana', countryCode: 'GH' },
    'greece': { country: 'Greece', countryCode: 'GR' },
    'guatemala': { country: 'Guatemala', countryCode: 'GT' },
    'haiti': { country: 'Haiti', countryCode: 'HT' },
    'hungary': { country: 'Hungary', countryCode: 'HU' },
    'iceland': { country: 'Iceland', countryCode: 'IS' },
    'india': { country: 'India', countryCode: 'IN' },
    'indonesia': { country: 'Indonesia', countryCode: 'ID' },
    'iran': { country: 'Iran', countryCode: 'IR' },
    'iraq': { country: 'Iraq', countryCode: 'IQ' },
    'ireland': { country: 'Ireland', countryCode: 'IE' },
    'israel': { country: 'Israel', countryCode: 'IL' },
    'italy': { country: 'Italy', countryCode: 'IT' },
    'jamaica': { country: 'Jamaica', countryCode: 'JM' },
    'japan': { country: 'Japan', countryCode: 'JP' },
    'jordan': { country: 'Jordan', countryCode: 'JO' },
    'kazakhstan': { country: 'Kazakhstan', countryCode: 'KZ' },
    'kenya': { country: 'Kenya', countryCode: 'KE' },
    'south korea': { country: 'South Korea', countryCode: 'KR' },
    'korea': { country: 'South Korea', countryCode: 'KR' },
    'lebanon': { country: 'Lebanon', countryCode: 'LB' },
    'libya': { country: 'Libya', countryCode: 'LY' },
    'malaysia': { country: 'Malaysia', countryCode: 'MY' },
    'mexico': { country: 'Mexico', countryCode: 'MX' },
    'morocco': { country: 'Morocco', countryCode: 'MA' },
    'nepal': { country: 'Nepal', countryCode: 'NP' },
    'netherlands': { country: 'Netherlands', countryCode: 'NL' },
    'new zealand': { country: 'New Zealand', countryCode: 'NZ' },
    'nicaragua': { country: 'Nicaragua', countryCode: 'NI' },
    'nigeria': { country: 'Nigeria', countryCode: 'NG' },
    'norway': { country: 'Norway', countryCode: 'NO' },
    'pakistan': { country: 'Pakistan', countryCode: 'PK' },
    'peru': { country: 'Peru', countryCode: 'PE' },
    'philippines': { country: 'Philippines', countryCode: 'PH' },
    'poland': { country: 'Poland', countryCode: 'PL' },
    'portugal': { country: 'Portugal', countryCode: 'PT' },
    'romania': { country: 'Romania', countryCode: 'RO' },
    'russia': { country: 'Russia', countryCode: 'RU' },
    'saudi arabia': { country: 'Saudi Arabia', countryCode: 'SA' },
    'senegal': { country: 'Senegal', countryCode: 'SN' },
    'serbia': { country: 'Serbia', countryCode: 'RS' },
    'singapore': { country: 'Singapore', countryCode: 'SG' },
    'somalia': { country: 'Somalia', countryCode: 'SO' },
    'south africa': { country: 'South Africa', countryCode: 'ZA' },
    'spain': { country: 'Spain', countryCode: 'ES' },
    'sri lanka': { country: 'Sri Lanka', countryCode: 'LK' },
    'sweden': { country: 'Sweden', countryCode: 'SE' },
    'switzerland': { country: 'Switzerland', countryCode: 'CH' },
    'syria': { country: 'Syria', countryCode: 'SY' },
    'taiwan': { country: 'Taiwan', countryCode: 'TW' },
    'thailand': { country: 'Thailand', countryCode: 'TH' },
    'turkey': { country: 'Turkey', countryCode: 'TR' },
    'ukraine': { country: 'Ukraine', countryCode: 'UA' },
    'united kingdom': { country: 'United Kingdom', countryCode: 'GB' },
    'uk': { country: 'United Kingdom', countryCode: 'GB' },
    'venezuela': { country: 'Venezuela', countryCode: 'VE' },
    'vietnam': { country: 'Vietnam', countryCode: 'VN' },
    'yemen': { country: 'Yemen', countryCode: 'YE' }
};

// Function to determine country from restaurant tags
function getCountryFromTags(tags) {
    for (const tag of tags) {
        const tagLower = tag.toLowerCase().trim();
        // Skip non-country tags
        if (tagLower === 'nyc' || tagLower === 'global belly food tour') {
            continue;
        }
        // Check if tag matches any country or cuisine
        if (countryMapping[tagLower]) {
            return countryMapping[tagLower];
        }
    }
    return null;
}

// Global Food Tour Map functionality - now using amCharts
let globalMapInstance = null;
let amChartsRoot = null;

function initializeGlobalMap() {
    const worldMapContainer = document.getElementById('world-map');
    if (!worldMapContainer) {
        return;
    }
    
    // Clean up any existing amCharts instance
    if (amChartsRoot) {
        amChartsRoot.dispose();
        amChartsRoot = null;
    }
    
    
    try {
        // Initialize amCharts
        am5.ready(() => {
            // Create root element
            amChartsRoot = am5.Root.new("world-map");

            // Set themes
            amChartsRoot.setThemes([
                am5themes_Animated.new(amChartsRoot)
            ]);

            // Create the map chart
            globalMapInstance = amChartsRoot.container.children.push(am5map.MapChart.new(amChartsRoot, {
                panX: "rotateX",
                panY: "translateY",
                projection: am5map.geoMercator(),
                maxZoomLevel: 8.0, // Allow much more zoom in
                minZoomLevel: 1.8, // Prevent zooming out from default
                zoomLevel: 1.8 // Start more zoomed in
            }));

            // Create main polygon series for countries
            var polygonSeries = globalMapInstance.series.push(am5map.MapPolygonSeries.new(amChartsRoot, {
                geoJSON: am5geodata_worldLow
            }));

            // Configure polygon appearance
            polygonSeries.mapPolygons.template.setAll({
                tooltipText: "{name}",
                interactive: false, // Default to not interactive
                fill: am5.color(0xe0e0e0), // Default gray color
                stroke: am5.color(0xffffff),
                strokeWidth: 1
            });

            // Add hover state
            polygonSeries.mapPolygons.template.states.create("hover", {
                fill: am5.color(0xcccccc)
            });

            // Load and color countries with Global Belly Food Tour restaurants
            loadGlobalBellyFoodTourCountries(polygonSeries);

            // Grid lines removed for cleaner appearance

            // Map click handler removed - using DOM-based handler instead

            // Make stuff animate on load
            globalMapInstance.appear(1000, 100);
            
        });
        
        // Add DOM-based click handler to world map container
        const worldMapContainer = document.getElementById('world-map');
        if (worldMapContainer) {
            worldMapContainer.addEventListener('click', function(event) {
                // Only close if NOT clicking on the popup
                if (!event.target.closest('#global-map-popup')) {
                    closeGlobalMapPopup();
                } else {
                }
            });
        }
        
        // Add escape key listener for closing popup
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                console.log('‚å®Ô∏è Escape key pressed');
                closeGlobalMapPopup();
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error initializing global map:', error);
    }
}

// Load Global Belly Food Tour countries and add restaurant popups
function loadGlobalBellyFoodTourCountries(polygonSeries) {
    
    // Filter restaurants that are tagged with "global belly food tour" AND have identifiable international cuisine
    const globalTourRestaurants = restaurants.filter(restaurant => {
        const hasGlobalTourTag = restaurant.tags.some(tag => 
            tag.toLowerCase().trim() === 'global belly food tour'
        );
        const countryInfo = getCountryFromTags(restaurant.tags);
        
        return hasGlobalTourTag && countryInfo !== null;
    }).map(restaurant => {
        const countryInfo = getCountryFromTags(restaurant.tags);
        return {
            ...restaurant,
            country: countryInfo.country,
            countryCode: countryInfo.countryCode
        };
    });
    
    
    // Group restaurants by country
    const restaurantsByCountry = {};
    globalTourRestaurants.forEach(restaurant => {
        if (!restaurantsByCountry[restaurant.countryCode]) {
            restaurantsByCountry[restaurant.countryCode] = [];
        }
        restaurantsByCountry[restaurant.countryCode].push(restaurant);
    });
    
    
    // Add data for countries with restaurants
    const countriesData = Object.keys(restaurantsByCountry).map(countryCode => ({
        id: countryCode,
        hasRestaurants: true,
        restaurantCount: restaurantsByCountry[countryCode].length
    }));
    
    polygonSeries.data.setAll(countriesData);
    
    // Wait for series to be ready, then color countries AND add click events
    polygonSeries.events.on("datavalidated", function() {
        const reviewedCountries = Object.keys(restaurantsByCountry);
        
        // Color each reviewed country
        reviewedCountries.forEach(countryCode => {
            const country = polygonSeries.getDataItemById(countryCode);
            if (country) {
                const polygon = country.get("mapPolygon");
                polygon.set("fill", am5.color(0xFF6600));
                polygon.set("interactive", true);
                polygon.set("cursorOverStyle", "pointer");
            }
        });

        // Add click events ONLY to reviewed countries
        reviewedCountries.forEach(countryCode => {
            const country = polygonSeries.getDataItemById(countryCode);
            if (country) {
                const polygon = country.get("mapPolygon");
                polygon.events.on("click", function(ev) {
                    // Stop all event propagation
                    if (ev.originalEvent) {
                        ev.originalEvent.stopPropagation();
                        ev.originalEvent.preventDefault();
                    }
                    
                    // Get click coordinates relative to the chart
                    const chartDiv = document.getElementById('world-map');
                    const chartRect = chartDiv.getBoundingClientRect();
                    const clickX = ev.originalEvent ? ev.originalEvent.clientX - chartRect.left : chartRect.width * 0.5;
                    const clickY = ev.originalEvent ? ev.originalEvent.clientY - chartRect.top : chartRect.height * 0.3;
                    
                    const dataItem = ev.target.dataItem;
                    if (dataItem) {
                        const countryCode = dataItem.get("id");
                        // Get country name from our mapping since amCharts name might be undefined
                        const countryInfo = Object.values(countryMapping).find(c => c.countryCode === countryCode);
                        const countryName = countryInfo ? countryInfo.country : countryCode;
                        
                        // Use setTimeout to show popup after current event cycle
                        setTimeout(() => {
                            showGlobalMapPopup(countryCode, countryName, clickX, clickY, restaurantsByCountry);
                        }, 10);
                    }
                });
            }
        });
    });
    
    // Update header with cuisine count
    const reviewedCount = Object.keys(restaurantsByCountry).length;
    updateGlobalMapHeader(reviewedCount);
}

// Get country coordinates dynamically from amCharts map data
function getCountryCoordinates(countryCode) {
    console.log('getCountryCoordinates called with:', countryCode);
    
    if (!globalMapInstance || !globalMapInstance.series || globalMapInstance.series.length === 0) {
        console.log('No global map instance or series available');
        return null;
    }
    
    const polygonSeries = globalMapInstance.series.getIndex(0);
    const country = polygonSeries.getDataItemById(countryCode);
    console.log('Found country data item:', country);
    
    if (country) {
        const polygon = country.get("mapPolygon");
        console.log('Found polygon:', polygon);
        if (polygon) {
            // Try to get the geographic center using amCharts' built-in method
            try {
                const geoPoint = polygon.get("geoCentroid");
                console.log('Geo centroid:', geoPoint);
                if (geoPoint && geoPoint.latitude !== undefined && geoPoint.longitude !== undefined) {
                    return [geoPoint.latitude, geoPoint.longitude];
                }
            } catch (e) {
                console.log('Error getting geo centroid:', e);
            }
            
            // Try alternative methods
            try {
                const polygonBounds = polygon.get("geoBounds");
                console.log('Geo bounds:', polygonBounds);
                if (polygonBounds) {
                    const centerLat = (polygonBounds.north + polygonBounds.south) / 2;
                    const centerLon = (polygonBounds.east + polygonBounds.west) / 2;
                    console.log('Calculated center from geo bounds:', [centerLat, centerLon]);
                    return [centerLat, centerLon];
                }
            } catch (e) {
                console.log('Error getting geo bounds:', e);
            }
            
            // Fallback to data item coordinates if available
            try {
                const dataItem = country;
                const geometry = dataItem.get("geometry");
                console.log('Geometry:', geometry);
                if (geometry && geometry.coordinates) {
                    // For simple geometries, try to calculate a rough center
                    console.log('Using fallback coordinate calculation');
                    // This is a very basic fallback - would need more complex logic for real polygons
                }
            } catch (e) {
                console.log('Error accessing geometry:', e);
            }
        }
    } else {
        console.log('Country not found in map data:', countryCode);
    }
    
    console.log('Could not determine coordinates, falling back to hardcoded values');
    // Fallback to hardcoded coordinates for critical countries
    const fallbackCoordinates = {
        'DM': [15.4, -61.3], // Dominica
        'AU': [-25, 135],    // Australia
        'US': [39.8, -98.5], // United States
        'CA': [56.1, -106.3], // Canada
        'CO': [4.0, -74.0],  // Colombia
        'ER': [15.0, 38.0],  // Eritrea
        'PH': [12.0, 122.0], // Philippines
        'ET': [8.0, 38.0],   // Ethiopia
        'PL': [52.0, 20.0],  // Poland
        'CU': [22.0, -79.0], // Cuba
        'YE': [15.0, 48.0],  // Yemen
        'BD': [24.0, 90.0],  // Bangladesh
        'AF': [33.0, 65.0]   // Afghanistan
    };
    
    return fallbackCoordinates[countryCode] || null;
}

// This code should be removed as it's part of disabled auto-popup functionality
function handlePendingCountryPopup() {
    // Completely disable auto-popups during initial map loading
    // Only process pending popups if explicitly triggered by user interaction
    if (false && window.pendingCountryPopup && globalMapInstance && globalMapContainer && !globalMapContainer.classList.contains('hidden')) {
        const countryInfo = window.pendingCountryPopup;
        
        // Find restaurants for this country
        const globalTourRestaurants = restaurants.filter(r => {
            const hasGBFTTag = r.tags.some(tag => 
                standardizeTag(tag) === 'global belly food tour'
            );
            const rCountryInfo = getCountryFromTags(r.tags);
            return hasGBFTTag && rCountryInfo && rCountryInfo.countryCode === countryInfo.countryCode;
        }).map(r => {
            const rCountryInfo = getCountryFromTags(r.tags);
            return {
                ...r,
                country: rCountryInfo.country,
                countryCode: rCountryInfo.countryCode
            };
        });
        
        const countryRestaurantsByCountry = {};
        countryRestaurantsByCountry[countryInfo.countryCode] = globalTourRestaurants;
        
        // Position popup consistently in upper right corner
        const chartDiv = document.getElementById('world-map');
        const chartRect = chartDiv ? chartDiv.getBoundingClientRect() : { width: 600, height: 400 };
        const clickX = chartRect.width - 320; // 320px from right edge
        const clickY = 50; // 50px from top
        
        // Show popup for this country
        showGlobalMapPopup(countryInfo.countryCode, countryInfo.country, clickX, clickY, countryRestaurantsByCountry);
        
        // Clear the pending request
        window.pendingCountryPopup = null;
    } else {
        // Clear any stale pending popup when switching to global map for first time
        window.pendingCountryPopup = null;
    }
}

// Show popup for global map with restaurant cards
// Function to get country emoji from country code
function getCountryEmoji(countryCode) {
    const countryEmojis = {
        'AU': 'üá¶üá∫', 'US': 'üá∫üá∏', 'CA': 'üá®üá¶', 'GB': 'üá¨üáß', 'DE': 'üá©üá™', 
        'FR': 'üá´üá∑', 'IT': 'üáÆüáπ', 'ES': 'üá™üá∏', 'JP': 'üáØüáµ', 'KR': 'üá∞üá∑', 
        'CN': 'üá®üá≥', 'IN': 'üáÆüá≥', 'BR': 'üáßüá∑', 'MX': 'üá≤üáΩ', 'AR': 'üá¶üá∑',
        'CL': 'üá®üá±', 'CO': 'üá®üá¥', 'PE': 'üáµüá™', 'TH': 'üáπüá≠', 'VN': 'üáªüá≥',
        'PH': 'üáµüá≠', 'MY': 'üá≤üáæ', 'SG': 'üá∏üá¨', 'ID': 'üáÆüá©', 'TR': 'üáπüá∑',
        'GR': 'üá¨üá∑', 'RU': 'üá∑üá∫', 'UA': 'üá∫üá¶', 'PL': 'üáµüá±', 'NL': 'üá≥üá±',
        'BE': 'üáßüá™', 'CH': 'üá®üá≠', 'AT': 'üá¶üáπ', 'SE': 'üá∏üá™', 'NO': 'üá≥üá¥',
        'DK': 'üá©üá∞', 'FI': 'üá´üáÆ', 'IS': 'üáÆüá∏', 'IE': 'üáÆüá™', 'PT': 'üáµüáπ',
        'ZA': 'üáøüá¶', 'EG': 'üá™üá¨', 'MA': 'üá≤üá¶', 'NG': 'üá≥üá¨', 'KE': 'üá∞üá™',
        'ET': 'üá™üáπ', 'GH': 'üá¨üá≠', 'TN': 'üáπüá≥', 'DZ': 'üá©üáø', 'LY': 'üá±üáæ',
        'IL': 'üáÆüá±', 'JO': 'üáØüá¥', 'LB': 'üá±üáß', 'SY': 'üá∏üáæ', 'IQ': 'üáÆüá∂',
        'IR': 'üáÆüá∑', 'SA': 'üá∏üá¶', 'AE': 'üá¶üá™', 'QA': 'üá∂üá¶', 'KW': 'üá∞üáº',
        'OM': 'üá¥üá≤', 'YE': 'üáæüá™', 'AF': 'üá¶üá´', 'PK': 'üáµüá∞', 'BD': 'üáßüá©',
        'LK': 'üá±üá∞', 'NP': 'üá≥üáµ', 'BT': 'üáßüáπ', 'MM': 'üá≤üá≤', 'LA': 'üá±üá¶',
        'KH': 'üá∞üá≠', 'BN': 'üáßüá≥', 'TW': 'üáπüáº', 'HK': 'üá≠üá∞', 'MO': 'üá≤üá¥'
    };
    return countryEmojis[countryCode] || 'üåç';
}

function showGlobalMapPopup(countryCode, countryName, clickX, clickY, restaurantsByCountry) {
    
    const restaurants = restaurantsByCountry[countryCode] || [];
    
    // Create popup if it doesn't exist
    let popup = document.getElementById('global-map-popup');
    if (!popup) {
        popup = document.createElement('div');
        popup.id = 'global-map-popup';
        popup.className = 'leaflet-popup';
        popup.innerHTML = `
            <div class="leaflet-popup-content-wrapper">
                <div class="leaflet-popup-content" id="global-popup-content">
                    <!-- Restaurant cards will be added here -->
                </div>
            </div>
        `;
        document.getElementById('world-map').appendChild(popup);
    }
    
    const content = document.getElementById('global-popup-content');
    
    const countryEmoji = getCountryEmoji(countryCode);
    const titleHtml = `<div class="popup-title" style="font-weight: bold; font-size: 1.1rem; margin-bottom: 10px; padding: 10px 15px; border-bottom: 1px solid #ddd; text-align: center;">${countryEmoji} ${countryName}</div>`;
    
    if (restaurants.length === 0) {
        content.innerHTML = titleHtml + '<div style="padding: 15px; text-align: center; color: #666; font-size: 0.9rem;">No cuisines reviewed yet in this country.</div>';
    } else {
        // Simple structure matching popup content
        content.innerHTML = titleHtml + restaurants.map(restaurant => {
            const mapsLink = generateGoogleMapsLink(restaurant);
            return `
                <div class="popup-content">
                    ${restaurant.tikTokThumbnail ? 
                        `<img src="${restaurant.tikTokThumbnail}" alt="${restaurant.restaurant}" class="popup-thumbnail" onerror="this.src='${restaurant.tikTokThumbnailFallback || 'https://via.placeholder.com/200x150/ccc/666?text=No+Image'}'; this.onerror=function(){this.style.display='none'}">` : 
                        ''
                    }
                    <div class="popup-name">${restaurant.restaurant}</div>
                    <div class="popup-address">üìç <span class="clickable-location">${restaurant.location}</span></div>
                    <div class="popup-address">${restaurant.address}</div>
                    <div class="popup-rating">
                        <span class="rating-value">${restaurant.rating.toFixed(1)}</span>
                        <img src="${getRatingIcon(restaurant.rating, restaurant.reviewer)}" alt="Bigger Belly Rating" class="rating-icon" onerror="this.src='src/vlad-bbb.png'">
                    </div>
                    <div class="popup-links">
                        ${restaurant.tikTokVideo ? 
                            `<a href="${restaurant.tikTokVideo}" target="_blank">Watch Review</a>` : 
                            ''
                        }
                        ${mapsLink ? 
                            `<a href="${mapsLink}" target="_blank">View on Maps</a>` : 
                            ''
                        }
                    </div>
                    <div class="popup-reviewer">Reviewed by: <span class="clickable-reviewer">${capitalizeForDisplay(restaurant.reviewer)}</span></div>
                </div>
            `;
        }).join('');
    }

    // Position popup within the map
    popup.style.display = 'block';
    
    // Get chart container dimensions
    const chartDiv = document.getElementById('world-map');
    const chartRect = chartDiv.getBoundingClientRect();
    
    let left = clickX || chartRect.width * 0.7; 
    let top = clickY || chartRect.height * 0.3; 
    
    // Keep popup within bounds
    if (left + 350 > chartRect.width) left = chartRect.width - 360;
    if (top + popup.offsetHeight > chartRect.height) top = chartRect.height - popup.offsetHeight - 10;
    if (left < 10) left = 10;
    if (top < 10) top = 10;
    
    popup.style.left = left + 'px';
    popup.style.top = top + 'px';
}

function closeGlobalMapPopup() {
    const popup = document.getElementById('global-map-popup');
    if (popup) {
        popup.style.display = 'none';
    } else {
    }
}


// Helper function to get rating icon
function getRatingIcon(rating, reviewer) {
    const reviewerIcon = reviewer === 'jason' ? 'jason-bbb.png' : 
                        reviewer === 'andrew' ? 'andrew-bbb.png' : 'vlad-bbb.png';
    return `src/${reviewerIcon}`;
}

// Helper function to capitalize for display
function capitalizeForDisplay(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// Update the global map header with cuisine count
function updateGlobalMapHeader(reviewedCount) {
    const headerP = document.querySelector('.global-map-header p');
    if (headerP) {
        const totalCountries = 195;
        const remaining = totalCountries - reviewedCount;
        headerP.textContent = `${reviewedCount} cuisines reviewed. ${remaining} to go.`;
    }
}

// Country coordinates for markers (approximate capitals/centers)
const countryCoordinates = {
    'ethiopia': [9.1450, 40.4897],
    'poland': [51.9194, 19.1451], 
    'cuba': [21.5218, -77.7812],
    'yemen': [15.552727, 48.516388],
    'bangladesh': [23.6850, 90.3563],
    'afghanistan': [33.9391, 67.7100],
    'philippines': [12.8797, 121.7740],
    'colombia': [4.5709, -74.2973],
    'eritrea': [15.7394, 38.9916],
    'united states': [39.8283, -98.5795],
    'usa': [39.8283, -98.5795],
    'mexico': [23.6345, -102.5528],
    'canada': [56.1304, -106.3468],
    'brazil': [-14.2350, -51.9253],
    'russia': [61.5240, 105.3188],
    'china': [35.8617, 104.1954],
    'india': [20.5937, 78.9629],
    'australia': [-25.2744, 133.7751],
    'france': [46.6034, 1.8883],
    'germany': [51.1657, 10.4515],
    'united kingdom': [55.3781, -3.4360],
    'uk': [55.3781, -3.4360],
    'south africa': [-30.5595, 22.9375]
};

// Store country layers for highlighting
let countryLayers = {};
let visitedCountryLayers = [];

function loadCountryBoundaries() {
    
    // Skip the complex GeoJSON and just use markers - this WILL work
    console.log('‚úÖ Ready for country markers');
    
    // Highlight any pending visited countries
    if (window.pendingVisitedCountries && window.pendingVisitedCountries.length > 0) {
        addVisitedCountryMarkers(window.pendingVisitedCountries);
        window.pendingVisitedCountries = null;
    }
}


// This function was removed - amCharts map handles country highlighting automatically


function updateGlobalMapHeader(countryCount) {
    const header = document.querySelector('.global-map-header');
    if (!header) return;
    
    const totalRestaurants = getFilteredRestaurants().length;
    const countriesRemaining = 195 - countryCount;
    
    header.innerHTML = `
        <h3>üåç Global Belly Food Tour (based in NYC üçéüóΩ)</h3>
        <p><strong>${countryCount} cuisines reviewed. ${countriesRemaining} to go.</strong></p>
    `;
}

function initializeSimpleMap() {
    // Fallback simple map if jVectorMap fails
    const worldMapContainer = document.getElementById('world-map');
    if (!worldMapContainer) return;
    
    
    // Get visited countries for the fallback
    const filteredRestaurants = getFilteredRestaurants();
    const visitedCountries = new Set();
    
    filteredRestaurants.forEach(restaurant => {
        restaurant.tags.forEach(tag => {
            const standardizedTag = standardizeTag(tag);
            if (standardizedTag !== 'global belly food tour' && 
                standardizedTag !== 'nyc' && 
                standardizedTag !== 'ny' &&
                standardizedTag !== 'new york') {
                
                // Country names for display
                const countryNames = {
                    'ethiopia': 'Ethiopia',
                    'poland': 'Poland', 
                    'cuba': 'Cuba',
                    'yemen': 'Yemen',
                    'bangladesh': 'Bangladesh',
                    'afghanistan': 'Afghanistan',
                    'philippines': 'Philippines',
                    'colombia': 'Colombia',
                    'eritrea': 'Eritrea'
                };
                
                if (countryNames[standardizedTag]) {
                    visitedCountries.add(countryNames[standardizedTag]);
                }
            }
        });
    });
    
    const countryList = Array.from(visitedCountries).join(', ');
    
    worldMapContainer.innerHTML = `
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 300px; background: #f8f9fa; border-radius: 8px; color: #666; padding: 2rem;">
            <div style="text-align: center;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üåç</div>
                <div style="font-size: 1.25rem; margin-bottom: 1rem; color: var(--primary-color);">Countries Visited</div>
                <div style="font-size: 1rem; line-height: 1.6; max-width: 400px;">
                    ${countryList || 'No countries found'}
                </div>
                <div style="font-size: 0.8rem; margin-top: 1.5rem; opacity: 0.7;">
                    Interactive world map unavailable
                </div>
            </div>
        </div>`;
}

function updateGlobalMap() {
    // Clear any pending popup data at start of global map operations
    window.pendingCountryPopup = null;
    
    const globalMapContainer = document.getElementById('global-map');
    if (!globalMapContainer) {
        console.log('‚ùå Global map container not found');
        return;
    }
    
    // Check if "global belly food tour" is selected
    const hasGlobalTourTag = Array.from(selectedTags).some(tag => 
        standardizeTag(tag) === 'global belly food tour'
    );
    
    
    if (hasGlobalTourTag) {
        // Show world map, hide local map
        globalMapContainer.classList.remove('hidden');
        const localMap = document.getElementById('map');
        if (localMap) {
            localMap.classList.add('hidden');
            localMap.style.display = 'none';
        }
        
        // Initialize map if not already done
        if (!globalMapInstance) {
            initializeGlobalMap();
        }
        
        // The amCharts map handles restaurant loading automatically when initialized
        
    } else {
        // Hide world map, show local map
        globalMapContainer.classList.add('hidden');
        const localMap = document.getElementById('map');
        if (localMap) {
            localMap.classList.remove('hidden');
            localMap.style.display = '';
        }
    }
}