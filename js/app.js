// Configuration
const CONFIG = {
    version: '2.8.0',
    // Restaurant data URL (JSON file generated by GitHub action)
    dataUrl: 'data/restaurants.json',
    
    // Default map center (will be updated based on restaurant locations)
    defaultCenter: [40.7128, -74.0060], // New York City
    defaultZoom: 10
};

// Global variables
let map;
let restaurants = [];
let markers = [];
let allTags = new Set();
let allReviewers = new Set();
let selectedTags = new Set();
// selectedReviewer removed - now using tags
let currentSort = 'newest';
let currentPage = 1;
let itemsPerPage = 12;
let totalFilteredRestaurants = 0;

// Debounce timer for rating slider
let ratingSliderDebounceTimer = null;

// Data variables
let restaurantData = null;

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    console.log(`üçî Bigger Belly Boys v${CONFIG.version} - Loading...`);
    initializeMap();
    setupEventListeners();
    setupBrowserNavigation();
    initializeFromUrl();
    loadRestaurantDataFromJSON();
    setupTabNavigation();
});

// Go to home page (clear all filters and URL parameters)
function goToHomePage() {
    // Clear all filters
    clearAllFilters();
    
    // Hide suggest form if shown
    hideSuggestFormFromUrl();
    
    // Remove all URL parameters and go to base URL
    window.history.pushState({}, '', window.location.pathname);
    
    // Reset to first page
    currentPage = 1;
    
    // Re-display all restaurants
    sortAndDisplayRestaurants();
}

// Load restaurant data from JSON file (generated by GitHub action)
async function loadRestaurantDataFromJSON() {
    const loadingElement = document.getElementById('loading');
    
    try {
        console.log('üìä Loading restaurant data from JSON...');
        const response = await fetch(`${CONFIG.dataUrl}?_t=${Date.now()}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log(`‚úÖ Loaded ${data.restaurants.length} restaurants from JSON (v${data.version})`);
        
        restaurants = data.restaurants;
        
        if (restaurants.length === 0) {
            throw new Error('No restaurants found in data');
        }
        
        // Populate global tag sets from loaded data
        populateTagSets();
        
        createMapMarkers();
        sortAndDisplayRestaurants();
        setupFilters();
        
        loadingElement.classList.add('hidden');
        console.log(`üéâ Application ready with ${restaurants.length} restaurants`);
        
    } catch (error) {
        console.error('‚ùå Error loading restaurant data:', error);
        loadingElement.innerHTML = `
            <div class="spinner" style="display: none;"></div>
            <p>Error loading restaurant data: ${error.message}</p>
            <p style="font-size: 0.9rem; margin-top: 1rem;">
                Please check your internet connection and try again.
            </p>
        `;
    }
}

// Populate global tag sets from restaurant data
function populateTagSets() {
    // Clear existing sets
    allTags.clear();
    allReviewers.clear();
    
    restaurants.forEach(restaurant => {
        // Add restaurant tags to global set
        if (restaurant.tags) {
            restaurant.tags.forEach(tag => allTags.add(tag));
        }
        
        // Add reviewer to global set
        if (restaurant.reviewer) {
            allReviewers.add(restaurant.reviewer);
        }
    });
}

// Initialize Leaflet map
function initializeMap() {
    map = L.map('map', {
        worldCopyJump: true,
        maxZoom: 20,
        minZoom: 2
    }).setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
    
    // Add CartoDB Positron tiles (clean, minimal style)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '¬© OpenStreetMap contributors ¬© CARTO',
        subdomains: 'abcd',
        maxZoom: 20
    }).addTo(map);
}

// Setup event listeners
function setupEventListeners() {
    // Filter toggle for mobile
    const filterToggle = document.getElementById('filter-toggle-btn');
    const filterContent = document.querySelector('.filter-content');
    
    filterToggle.addEventListener('click', function() {
        filterContent.classList.toggle('active');
    });
    
    // Clear filters button
    document.getElementById('clear-filters').addEventListener('click', clearAllFilters);
    
    // Tag search filter
    setupTagSearch();
    
    // Rating slider filter
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    
    ratingSlider.addEventListener('input', function() {
        const value = parseFloat(this.value);
        ratingValueDisplay.textContent = value === 0 ? '0+' : `${value}+`;
        currentPage = 1; // Reset to first page when rating changes
        
        // Clear existing timer
        if (ratingSliderDebounceTimer) {
            clearTimeout(ratingSliderDebounceTimer);
        }
        
        // Apply filters immediately (for instant visual feedback)
        applyFilters(true); // Skip URL update
        
        // Set new timer to update URL after user stops sliding
        ratingSliderDebounceTimer = setTimeout(() => {
            updateUrl(); // Update URL after 500ms delay
            ratingSliderDebounceTimer = null;
        }, 500);
    });
    
    // Sort filter
    document.getElementById('sort-filter').addEventListener('change', function() {
        currentSort = this.value;
        currentPage = 1; // Reset to first page when sorting changes
        updateUrl();
        sortAndDisplayRestaurants();
    });
}

// Initialize state from URL parameters
function initializeFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    
    // Get page from URL
    const pageParam = urlParams.get('page');
    if (pageParam) {
        const page = parseInt(pageParam);
        if (page > 0) {
            currentPage = page;
        }
    }
    
    // Get sort from URL
    const sortParam = urlParams.get('sort');
    if (sortParam && ['newest', 'oldest', 'rating-desc', 'rating-asc'].includes(sortParam)) {
        currentSort = sortParam;
        // Update the dropdown to match
        const sortDropdown = document.getElementById('sort-filter');
        if (sortDropdown) {
            sortDropdown.value = sortParam;
        }
    }
    
    // Get tags from URL
    const tagsParam = urlParams.get('tags');
    if (tagsParam) {
        selectedTags.clear();
        const tags = tagsParam.split(',').map(tag => tag.trim()).filter(tag => tag);
        tags.forEach(tag => selectedTags.add(tag));
        // Update display after DOM is ready
        setTimeout(() => updateSelectedTagsDisplay(), 0);
    }
    
    // Get rating from URL
    const ratingParam = urlParams.get('rating');
    if (ratingParam) {
        const rating = parseFloat(ratingParam);
        if (!isNaN(rating)) {
            const ratingSlider = document.getElementById('rating-filter');
            if (ratingSlider) {
                ratingSlider.value = rating.toString();
                const ratingValueDisplay = document.getElementById('rating-value');
                if (ratingValueDisplay) {
                    ratingValueDisplay.textContent = `${rating}+`;
                }
            }
        }
    }
    
    // Get suggest form state from URL
    const suggestParam = urlParams.get('suggest');
    if (suggestParam === 'true') {
        // Delay showing suggest form until after DOM is ready
        setTimeout(() => {
            showSuggestFormFromUrl();
        }, 0);
    }
    
    // Create initial history entry with current state
    const url = new URL(window.location);
    if (currentPage > 1) {
        url.searchParams.set('page', currentPage.toString());
    }
    if (currentSort !== 'newest') {
        url.searchParams.set('sort', currentSort);
    }
    if (selectedTags.size > 0) {
        url.searchParams.set('tags', Array.from(selectedTags).join(','));
    }
    if (ratingParam && !isNaN(parseFloat(ratingParam))) {
        url.searchParams.set('rating', ratingParam);
    }
    if (suggestParam === 'true') {
        url.searchParams.set('suggest', 'true');
    }
    window.history.replaceState({}, '', url);
}

// Initialize state from URL parameters (for navigation only - no history modification)
function initializeFromUrlForNavigation() {
    const urlParams = new URLSearchParams(window.location.search);
    
    // Get page from URL
    const pageParam = urlParams.get('page');
    if (pageParam) {
        const page = parseInt(pageParam);
        if (page > 0) {
            currentPage = page;
        }
    } else {
        currentPage = 1;
    }
    
    // Get suggest form state from URL
    const suggestParam = urlParams.get('suggest');
    if (suggestParam === 'true') {
        showSuggestFormFromUrl();
    } else {
        hideSuggestFormFromUrl();
    }
    
    // Get sort from URL
    const sortParam = urlParams.get('sort');
    if (sortParam && ['newest', 'oldest', 'rating-desc', 'rating-asc'].includes(sortParam)) {
        currentSort = sortParam;
        // Update the dropdown to match
        const sortDropdown = document.getElementById('sort-filter');
        if (sortDropdown) {
            sortDropdown.value = sortParam;
        }
    } else {
        currentSort = 'newest';
        const sortDropdown = document.getElementById('sort-filter');
        if (sortDropdown) {
            sortDropdown.value = 'newest';
        }
    }
    
    // Get tags from URL
    const tagsParam = urlParams.get('tags');
    selectedTags.clear();
    if (tagsParam) {
        const tags = tagsParam.split(',').map(tag => tag.trim()).filter(tag => tag);
        tags.forEach(tag => selectedTags.add(tag));
    }
    updateSelectedTagsDisplay();
    
    // Get rating from URL
    const ratingParam = urlParams.get('rating');
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    
    if (ratingParam && ratingSlider) {
        const rating = parseFloat(ratingParam);
        if (!isNaN(rating)) {
            ratingSlider.value = rating.toString();
            if (ratingValueDisplay) {
                ratingValueDisplay.textContent = `${rating}+`;
            }
        }
    } else if (ratingSlider) {
        // Reset to minimum if no rating param
        ratingSlider.value = ratingSlider.min;
        if (ratingValueDisplay) {
            ratingValueDisplay.textContent = `${ratingSlider.min}+`;
        }
    }
    
}

// Update URL with current state
function updateUrl() {
    const oldUrl = window.location.href;
    const url = new URL(window.location);
    
    // Set page parameter
    if (currentPage > 1) {
        url.searchParams.set('page', currentPage.toString());
    } else {
        url.searchParams.delete('page');
    }
    
    // Set sort parameter
    if (currentSort !== 'newest') {
        url.searchParams.set('sort', currentSort);
    } else {
        url.searchParams.delete('sort');
    }
    
    // Set tags parameter
    if (selectedTags.size > 0) {
        url.searchParams.set('tags', Array.from(selectedTags).join(','));
    } else {
        url.searchParams.delete('tags');
    }
    
    // Set rating parameter
    const ratingSlider = document.getElementById('rating-filter');
    if (ratingSlider) {
        const currentRating = parseFloat(ratingSlider.value);
        const minRating = parseFloat(ratingSlider.min);
        if (currentRating > minRating) {
            url.searchParams.set('rating', currentRating.toString());
        } else {
            url.searchParams.delete('rating');
        }
    }
    
    // Set suggest parameter (for suggest form state)
    const suggestTab = document.getElementById('suggest-tab');
    if (suggestTab && !suggestTab.classList.contains('hidden')) {
        url.searchParams.set('suggest', 'true');
    } else {
        url.searchParams.delete('suggest');
    }
    
    const newUrl = url.href;
    
    // Only push to history if the URL actually changed
    if (oldUrl !== newUrl) {
        window.history.pushState({}, '', url);
    }
}

// Setup browser navigation (back/forward buttons)
function setupBrowserNavigation() {
    window.addEventListener('popstate', function(event) {
        // Re-initialize from URL parameters when user navigates
        initializeFromUrlForNavigation();
        
        // If restaurants are already loaded, apply the URL state immediately
        if (restaurants.length > 0) {
            sortAndDisplayRestaurants();
            // Also apply filters to ensure everything is in sync (skip URL update to avoid creating new history)
            applyFilters(true);
        }
    });
}


// Extract TikTok video ID from URL
function extractTikTokVideoId(url) {
    if (!url) return null;
    const match = url.match(/\/video\/(\d+)/);
    return match ? match[1] : null;
}

// Get cached thumbnail path for a TikTok video
function getCachedThumbnailPath(tikTokVideoUrl) {
    const videoId = extractTikTokVideoId(tikTokVideoUrl);
    return videoId ? `thumbnails/${videoId}.jpeg` : null;
}

// Check if cached thumbnail actually exists
async function cachedThumbnailExists(thumbnailPath) {
    if (!thumbnailPath) return false;
    
    try {
        const response = await fetch(thumbnailPath, { method: 'HEAD' });
        return response.ok;
    } catch (error) {
        return false;
    }
}

// Location mapping and standardization system
const LOCATION_MAPPINGS = {
    // US States and territories
    'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California',
    'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia',
    'HI': 'Hawaii', 'ID': 'Idaho', 'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa',
    'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
    'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi', 'MO': 'Missouri',
    'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
    'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio',
    'OK': 'Oklahoma', 'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
    'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont',
    'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming',
    'PR': 'Puerto Rico', 'DC': 'District of Columbia',
    
    // Countries (common abbreviations)
    'MX': 'Mexico', 'JP': 'Japan', 'UK': 'United Kingdom', 'FR': 'France', 'DE': 'Germany',
    'IT': 'Italy', 'ES': 'Spain', 'AU': 'Australia', 'NZ': 'New Zealand', 'SG': 'Singapore',
    'TH': 'Thailand', 'PH': 'Philippines', 'KR': 'South Korea', 'TW': 'Taiwan', 'HK': 'Hong Kong'
};

// Parse location from Location column (not address)
function parseLocationData(locationString) {
    if (!locationString) return { city: '', region: '', fullLocation: '', searchableLocation: '' };
    
    // Parse "City, Region" format from Location column
    const parts = locationString.split(',').map(part => part.trim());
    
    if (parts.length >= 2) {
        const city = parts[0];
        const region = parts[1];
        
        // Get full region name for display (e.g., "PR" -> "Puerto Rico")
        const fullRegion = LOCATION_MAPPINGS[region.toUpperCase()] || region;
        
        // Create searchable location string (for filtering)
        const searchableLocation = `${city}, ${fullRegion}`.toLowerCase();
        
        return {
            city: city,
            region: region,
            fullRegion: fullRegion,
            fullLocation: `${city}, ${fullRegion}`,
            searchableLocation: searchableLocation,
            originalLocation: locationString,
            // Standardized versions for filtering
            cityStandardized: standardizeTag(city),
            fullRegionStandardized: standardizeTag(fullRegion),
            fullLocationStandardized: standardizeTag(`${city}, ${fullRegion}`)
        };
    }
    
    // Fallback for single location (just city)
    return {
        city: locationString,
        region: '',
        fullRegion: '',
        fullLocation: locationString,
        searchableLocation: locationString.toLowerCase(),
        originalLocation: locationString,
        // Standardized versions for filtering
        cityStandardized: standardizeTag(locationString),
        fullRegionStandardized: '',
        fullLocationStandardized: standardizeTag(locationString)
    };
}

// Extract city from address string (fallback only)
function extractCityFromAddress(address) {
    if (!address) return '';
    
    // Common address formats:
    // "123 Main St, New York, NY 10001"
    // "456 Oak Ave, Los Angeles, CA"
    // "789 Pine Rd, Chicago IL 60601"
    
    const parts = address.split(',').map(part => part.trim());
    
    if (parts.length >= 2) {
        // Second part is usually the city
        let city = parts[1].trim();
        
        // Remove state abbreviations and zip codes from city name
        city = city.replace(/\s+[A-Z]{2}(\s+\d{5})?$/i, '').trim();
        
        return city;
    }
    
    // Fallback: try to extract from single comma-separated format
    if (parts.length === 1) {
        const match = address.match(/,\s*([^,\d]+?)(?:\s+[A-Z]{2})?\s*\d*$/i);
        if (match) {
            return match[1].trim();
        }
    }
    
    return '';
}

// Format address with clickable location (city for filtering)
function formatAddressWithClickableLocation(address, locationData) {
    if (!locationData || !locationData.city) return address;
    
    const city = locationData.city;
    
    // Replace the city part in the address with a clickable span
    const cityRegex = new RegExp(`(,\\s*)(${city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(\\s*,|\\s+[A-Z]{2}|\\s*$)`, 'i');
    
    // Use the full display location (e.g., "San Juan, Puerto Rico") for the filter
    const filterLocation = locationData.fullLocation;
    
    return address.replace(cityRegex, (match, beforeCity, cityMatch, afterCity) => {
        return `${beforeCity}<span class="clickable-city" onclick="selectLocationTag(event, '${filterLocation}')" title="Filter by ${filterLocation}">${cityMatch}</span>${afterCity}`;
    });
}

// Legacy function for backwards compatibility
function formatAddressWithClickableCity(address, city) {
    if (!city) return address;
    
    // Replace the city part in the address with a clickable span
    const cityRegex = new RegExp(`(,\\s*)(${city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(\\s*,|\\s+[A-Z]{2}|\\s*$)`, 'i');
    
    return address.replace(cityRegex, (match, beforeCity, cityMatch, afterCity) => {
        return `${beforeCity}<span class="clickable-city" onclick="selectCityTag(event, '${city}')">${cityMatch}</span>${afterCity}`;
    });
}

// Get reviewer-specific rating icon with fallback
function getReviewerIcon(reviewer) {
    if (!reviewer) return 'src/vlad-bbb.png';
    
    const reviewerName = reviewer.toLowerCase().trim();
    switch (reviewerName) {
        case 'andrew':
            return 'src/andrew-bbb.png';
        case 'jason':
            return 'src/jason-bbb.png';
        default:
            return 'src/vlad-bbb.png';
    }
}

// Get rating icon with special case for 6.7
function getRatingIcon(rating, reviewer) {
    // Special case for 6.7 - use numeric image
    if (rating === 6.7) {
        return 'src/67.png';
    }
    
    // For all other ratings, use reviewer-specific icon
    return getReviewerIcon(reviewer);
}

// Standardize tag formatting (lowercase, trimmed)
function standardizeTag(tag) {
    return tag ? tag.toString().toLowerCase().trim() : '';
}

// Capitalize first letter for display purposes
function capitalizeForDisplay(text) {
    if (!text) return text;
    return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
}

// Generate Google Maps link from address and coordinates
function generateGoogleMapsLink(restaurant) {
    // If we have a manual Google Maps link, use it
    if (restaurant.googleMapsLink && restaurant.googleMapsLink.trim()) {
        return restaurant.googleMapsLink.trim();
    }
    
    // Generate search query with restaurant name and address
    const restaurantName = restaurant.restaurant || '';
    const address = restaurant.address || '';
    const searchQuery = `${restaurantName} ${address}`.trim();
    
    if (restaurant.latitude && restaurant.longitude && !isNaN(restaurant.latitude) && !isNaN(restaurant.longitude)) {
        // Use coordinates with restaurant name + address for better accuracy
        return `https://www.google.com/maps/search/${encodeURIComponent(searchQuery)}/@${restaurant.latitude},${restaurant.longitude},15z`;
    } else if (searchQuery) {
        // Fallback to restaurant name + address search
        return `https://www.google.com/maps/search/${encodeURIComponent(searchQuery)}`;
    }
    
    return null;
}


// Create map markers
function createMapMarkers() {
    restaurants.forEach((restaurant, index) => {
        const marker = L.marker([restaurant.latitude, restaurant.longitude])
            .addTo(map)
            .bindPopup(createPopupContent(restaurant));
        
        // Store reference to restaurant data
        marker.restaurantIndex = index;
        markers.push(marker);
    });
}

// Create popup content for map markers
function createPopupContent(restaurant) {
    const mapsLink = generateGoogleMapsLink(restaurant);
    
    return `
        <div class="popup-content">
            ${restaurant.tikTokThumbnail ? 
                `<img src="${restaurant.tikTokThumbnail}" alt="${restaurant.restaurant}" class="popup-thumbnail" onerror="this.src='${restaurant.tikTokThumbnailFallback}'; this.onerror=function(){this.style.display='none'}">` : 
                ''
            }
            <div class="popup-name">${restaurant.restaurant}</div>
            <div class="popup-location">üìç <span class="clickable-location" onclick="selectLocationTag(event, '${restaurant.locationData.fullLocation}')" title="Filter by ${restaurant.locationData.fullLocation}">${restaurant.locationData.fullLocation}</span></div>
            <div class="popup-address">${restaurant.address}</div>
            <div class="popup-rating">
                <span class="rating-value">${restaurant.rating.toFixed(1)}</span>
                <img src="${getRatingIcon(restaurant.rating, restaurant.reviewer)}" alt="Bigger Belly Rating ${restaurant.rating.toFixed(1)}" class="rating-icon" onerror="this.src='src/vlad-bbb.png'">
            </div>
            <div class="popup-links">
                ${restaurant.tikTokVideo ? 
                    `<a href="${restaurant.tikTokVideo}" target="_blank">Watch Review</a>` : 
                    ''
                }
                ${mapsLink ? 
                    `<a href="${mapsLink}" target="_blank">View on Maps</a>` : 
                    ''
                }
            </div>
            <div class="popup-reviewer">Reviewed by: <span class="clickable-reviewer" onclick="selectReviewer('${restaurant.reviewer}')">${capitalizeForDisplay(restaurant.reviewer)}</span></div>
        </div>
    `;
}

// Sort and display restaurants
function sortAndDisplayRestaurants() {
    // Sort restaurants based on current sort option
    let sortedRestaurants = [...restaurants];
    
    switch (currentSort) {
        case 'rating-asc':
            sortedRestaurants.sort((a, b) => a.rating - b.rating);
            break;
        case 'rating-desc':
            sortedRestaurants.sort((a, b) => b.rating - a.rating);
            break;
        case 'oldest':
            // Sort by date posted (oldest first)
            sortedRestaurants.sort((a, b) => {
                const dateA = a.datePosted ? new Date(a.datePosted) : new Date(0);
                const dateB = b.datePosted ? new Date(b.datePosted) : new Date(0);
                return dateA - dateB;
            });
            break;
        case 'newest':
        default:
            // Sort by date posted (newest first)
            sortedRestaurants.sort((a, b) => {
                const dateA = a.datePosted ? new Date(a.datePosted) : new Date(0);
                const dateB = b.datePosted ? new Date(b.datePosted) : new Date(0);
                return dateB - dateA;
            });
            break;
    }
    
    createRestaurantCards(sortedRestaurants);
    // Apply filters after creating new cards
    applyFilters();
}

// Create restaurant cards with pagination
function createRestaurantCards(sortedRestaurants = restaurants) {
    const restaurantList = document.getElementById('restaurant-list');
    restaurantList.innerHTML = '';
    
    // Store all sorted restaurants for filtering/pagination
    window.currentSortedRestaurants = sortedRestaurants;
    
    // Apply pagination - this will be updated by applyFilters
    displayPaginatedRestaurants(sortedRestaurants);
}

// Display paginated restaurants
function displayPaginatedRestaurants(filteredRestaurants) {
    const restaurantList = document.getElementById('restaurant-list');
    restaurantList.innerHTML = '';
    
    // Update total for pagination
    totalFilteredRestaurants = filteredRestaurants.length;
    
    // Calculate pagination
    const totalPages = Math.ceil(totalFilteredRestaurants / itemsPerPage);
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, totalFilteredRestaurants);
    
    // Get restaurants for current page
    const restaurantsToShow = filteredRestaurants.slice(startIndex, endIndex);
    
    restaurantsToShow.forEach((restaurant, index) => {
        const originalIndex = restaurants.indexOf(restaurant);
        const card = document.createElement('div');
        card.className = 'restaurant-card';
        card.dataset.index = originalIndex; // Use original index for filtering
        
        const tagsHtml = restaurant.tags.map(tag => `<span class="tag clickable-tag" onclick="selectTag('${tag}')">${tag}</span>`).join('');
        
        card.innerHTML = `
            ${restaurant.tikTokThumbnail ? 
                `<img src="${restaurant.tikTokThumbnail}" alt="${restaurant.restaurant}" class="restaurant-thumbnail" onerror="this.src='${restaurant.tikTokThumbnailFallback}'; this.onerror=function(){this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjE1MCIgdmlld0JveD0iMCAwIDMwMCAxNTAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMTUwIiBmaWxsPSIjRjBGMEYwIi8+Cjx0ZXh0IHg9IjE1MCIgeT0iNzUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIiBmaWxsPSIjOTk5IiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTQiPk5vIEltYWdlPC90ZXh0Pgo8L3N2Zz4K'}">` : 
                `<div class="restaurant-thumbnail no-image" style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px; aspect-ratio: 1177 / 1570;">No Image</div>`
            }
            <div class="restaurant-info">
                <div class="restaurant-name">${restaurant.restaurant}</div>
                <div class="restaurant-location">üìç <span class="clickable-location" onclick="selectLocationTag(event, '${restaurant.locationData.fullLocation}')" title="Filter by ${restaurant.locationData.fullLocation}">${restaurant.locationData.fullLocation}</span></div>
                <div class="restaurant-address">${restaurant.address}</div>
                <div class="restaurant-rating">
                    <span class="rating-value">${restaurant.rating.toFixed(1)}</span>
                    <img src="${getRatingIcon(restaurant.rating, restaurant.reviewer)}" alt="Bigger Belly Rating ${restaurant.rating.toFixed(1)}" class="rating-icon" onerror="this.src='src/vlad-bbb.png'">
                </div>
                <div class="restaurant-tags">${tagsHtml}</div>
                <div class="restaurant-reviewer">Reviewed by: <span class="clickable-reviewer" onclick="selectReviewer('${restaurant.reviewer}')">${capitalizeForDisplay(restaurant.reviewer)}</span></div>
            </div>
        `;
        
        // Add click event to zoom to marker
        card.addEventListener('click', () => {
            const marker = markers[originalIndex];
            map.setView([restaurant.latitude, restaurant.longitude], 15);
            marker.openPopup();
        });
        
        restaurantList.appendChild(card);
    });
    
    // Update pagination controls
    updatePaginationControls();
    
    // Center map on first result when results change
    if (currentPage === 1) {
        centerMapOnFirstResult();
    }
}

// Update pagination controls
function updatePaginationControls() {
    const paginationContainer = document.getElementById('pagination');
    const totalPages = Math.ceil(totalFilteredRestaurants / itemsPerPage);
    
    if (totalPages <= 1) {
        paginationContainer.innerHTML = '';
        return;
    }
    
    let paginationHtml = '<div class="pagination">';
    
    // Previous button
    if (currentPage > 1) {
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(${currentPage - 1})">‚Üê Previous</button>`;
    }
    
    // Page numbers - show up to 5 page numbers
    const maxPagesToShow = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
    let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);
    
    // Adjust start page if we're near the end
    if (endPage - startPage + 1 < maxPagesToShow) {
        startPage = Math.max(1, endPage - maxPagesToShow + 1);
    }
    
    // Add first page and ellipsis if needed
    if (startPage > 1) {
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(1)">1</button>`;
        if (startPage > 2) {
            paginationHtml += '<span class="pagination-ellipsis">...</span>';
        }
    }
    
    // Add page numbers
    for (let i = startPage; i <= endPage; i++) {
        const activeClass = i === currentPage ? ' active' : '';
        paginationHtml += `<button class="pagination-btn${activeClass}" onclick="goToPage(${i})">${i}</button>`;
    }
    
    // Add last page and ellipsis if needed
    if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
            paginationHtml += '<span class="pagination-ellipsis">...</span>';
        }
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(${totalPages})">${totalPages}</button>`;
    }
    
    // Next button
    if (currentPage < totalPages) {
        paginationHtml += `<button class="pagination-btn" onclick="goToPage(${currentPage + 1})">Next ‚Üí</button>`;
    }
    
    paginationHtml += '</div>';
    
    // Add results info
    const startResult = totalFilteredRestaurants === 0 ? 0 : (currentPage - 1) * itemsPerPage + 1;
    const endResult = Math.min(currentPage * itemsPerPage, totalFilteredRestaurants);
    paginationHtml += `<div class="pagination-info">Showing ${startResult}-${endResult} of ${totalFilteredRestaurants} restaurants</div>`;
    
    paginationContainer.innerHTML = paginationHtml;
}

// Navigate to a specific page
function goToPage(page) {
    const totalPages = Math.ceil(totalFilteredRestaurants / itemsPerPage);
    
    if (page >= 1 && page <= totalPages) {
        currentPage = page;
        updateUrl();
        
        // Get current filtered restaurants and display the correct page
        const filteredRestaurants = getFilteredRestaurants();
        displayPaginatedRestaurants(filteredRestaurants);
        
        // Scroll to top of restaurant list
        document.getElementById('restaurant-list').scrollIntoView({ behavior: 'smooth' });
    }
}

// Setup filter controls
function setupFilters() {
    setupDynamicRatingSlider();
}

// Setup dynamic rating slider based on actual data
function setupDynamicRatingSlider() {
    const ratings = restaurants.map(r => r.rating).filter(rating => rating > 0);
    
    if (ratings.length === 0) return;
    
    const minRating = Math.min(...ratings);
    const maxRating = Math.max(...ratings);
    
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    
    // Update slider attributes
    ratingSlider.min = minRating;
    ratingSlider.max = maxRating;
    ratingSlider.value = minRating;
    ratingSlider.step = '0.1';
    
    // Update display
    ratingValueDisplay.textContent = `${minRating}+`;
    
    // Update slider labels
    const sliderLabels = document.querySelector('.slider-labels');
    sliderLabels.innerHTML = `
        <span>${minRating}</span>
        <span id="rating-value">${minRating}+</span>
        <span>${maxRating}</span>
    `;
    
    // Re-attach the event listener for the updated slider with debounce
    ratingSlider.addEventListener('input', function() {
        const value = parseFloat(this.value);
        const newRatingValueDisplay = document.getElementById('rating-value');
        newRatingValueDisplay.textContent = `${value}+`;
        currentPage = 1; // Reset to first page when rating changes
        
        // Clear existing timer
        if (ratingSliderDebounceTimer) {
            clearTimeout(ratingSliderDebounceTimer);
        }
        
        // Apply filters immediately (for instant visual feedback)
        applyFilters(true); // Skip URL update
        
        // Set new timer to update URL after user stops sliding
        ratingSliderDebounceTimer = setTimeout(() => {
            updateUrl(); // Update URL after 500ms delay
            ratingSliderDebounceTimer = null;
        }, 500);
    });
    
}

// Setup tag search with autocomplete and multi-select
function setupTagSearch() {
    const tagInput = document.getElementById('tag-search');
    const suggestionsContainer = document.getElementById('tag-suggestions');
    const selectedTagsContainer = document.getElementById('selected-tags');
    
    tagInput.addEventListener('input', function() {
        const query = this.value.toLowerCase().trim();
        
        if (query.length === 0) {
            suggestionsContainer.classList.add('hidden');
            return;
        }
        
        // Get tags from restaurants that match current filters
        const currentRating = parseFloat(document.getElementById('rating-filter').value) || 0;
        
        const availableTagsFromFilteredRestaurants = new Set();
        restaurants.forEach(restaurant => {
            // Check if restaurant matches current selected tags and rating
            let matchesSelectedTags = true;
            if (selectedTags.size > 0) {
                matchesSelectedTags = Array.from(selectedTags).every(selectedTag => {
                    const standardizedSelectedTag = standardizeTag(selectedTag);
                    
                    // Check if it matches a regular tag (already standardized)
                    const matchesTag = restaurant.tags.some(restaurantTag => 
                        restaurantTag === standardizedSelectedTag
                    );
                    // Or check if it matches the reviewer (already standardized)
                    const matchesReviewer = restaurant.reviewer === standardizedSelectedTag;
                    // Or check if it matches location data (only city name)
                    const matchesLocation = restaurant.locationData && 
                                          restaurant.locationData.cityStandardized === standardizedSelectedTag;
                    
                    return matchesTag || matchesReviewer || matchesLocation;
                });
            }
            
            const matchesRating = restaurant.rating >= currentRating;
            
            if (matchesSelectedTags && matchesRating) {
                // Add regular tags (already standardized during processing)
                restaurant.tags.forEach(tag => availableTagsFromFilteredRestaurants.add(tag));
                // Add this restaurant's reviewer as available tag (already standardized)
                if (restaurant.reviewer) {
                    availableTagsFromFilteredRestaurants.add(restaurant.reviewer);
                }
                // Add location-based tags (only city name)
                if (restaurant.locationData && restaurant.locationData.cityStandardized) {
                    availableTagsFromFilteredRestaurants.add(restaurant.locationData.cityStandardized);
                }
            }
        });
        
        // Filter available tags based on input and current filters
        const availableTags = Array.from(availableTagsFromFilteredRestaurants).filter(tag => {
            return tag.toLowerCase().includes(query) && !selectedTags.has(tag);
        });
        
        if (availableTags.length === 0) {
            suggestionsContainer.classList.add('hidden');
            return;
        }
        
        // Show suggestions
        suggestionsContainer.innerHTML = '';
        availableTags.slice(0, 8).forEach(tag => { // Limit to 8 suggestions
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'tag-suggestion-item';
            suggestionItem.textContent = tag;
            suggestionItem.addEventListener('click', () => selectTag(tag));
            suggestionsContainer.appendChild(suggestionItem);
        });
        
        suggestionsContainer.classList.remove('hidden');
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener('click', function(e) {
        if (!tagInput.contains(e.target) && !suggestionsContainer.contains(e.target)) {
            suggestionsContainer.classList.add('hidden');
        }
    });
    
    // Handle Enter key to select first suggestion
    tagInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            const firstSuggestion = suggestionsContainer.querySelector('.tag-suggestion-item');
            if (firstSuggestion) {
                selectTag(firstSuggestion.textContent);
            }
        }
    });
}

function selectTag(tag) {
    const standardizedTag = standardizeTag(tag);
    
    // Don't add if already selected (check standardized version)
    if (Array.from(selectedTags).some(selectedTag => standardizeTag(selectedTag) === standardizedTag)) {
        return;
    }
    
    selectedTags.add(standardizedTag);
    updateSelectedTagsDisplay();
    
    // Clear input and hide suggestions
    document.getElementById('tag-search').value = '';
    document.getElementById('tag-suggestions').classList.add('hidden');
    
    // Auto-expand filters on mobile when tag is selected
    expandFiltersOnMobile();
    
    // Reset to first page when tag is selected
    currentPage = 1;
    updateUrl();
    
    applyFilters();
}

// Select city tag with event handling (prevents card click zooming)
function selectCityTag(event, city) {
    // Prevent event from bubbling up to the restaurant card click handler
    event.stopPropagation();
    
    // Use the regular selectTag function for the filtering logic
    selectTag(city);
}

// Select location tag with event handling (prevents card click zooming)
function selectLocationTag(event, location) {
    // Prevent event from bubbling up to the restaurant card click handler
    event.stopPropagation();
    
    // Extract city name from full location (everything before the first comma)
    const cityName = location.split(',')[0].trim();
    
    // Use the regular selectTag function with just the city name
    selectTag(cityName);
}

// Auto-expand filters on mobile when interaction happens
function expandFiltersOnMobile() {
    // Check if we're on mobile (filter toggle is visible)
    const filterToggle = document.getElementById('filter-toggle-btn');
    if (filterToggle && window.getComputedStyle(filterToggle).display !== 'none') {
        const filterContent = document.querySelector('.filter-content');
        if (filterContent && !filterContent.classList.contains('active')) {
            filterContent.classList.add('active');
        }
    }
}

function removeTag(tag) {
    selectedTags.delete(tag);
    updateSelectedTagsDisplay();
    
    // Reset to first page when tag is removed
    currentPage = 1;
    updateUrl();
    
    applyFilters();
}

function selectReviewer(reviewer) {
    // Auto-expand filters on mobile when reviewer is selected
    expandFiltersOnMobile();
    // Now just use the existing tag selection system
    selectTag(reviewer);
}

function updateSelectedTagsDisplay() {
    const container = document.getElementById('selected-tags');
    container.innerHTML = '';
    
    selectedTags.forEach(tag => {
        const tagElement = document.createElement('div');
        tagElement.className = 'selected-tag';
        tagElement.innerHTML = `
            <span>${tag}</span>
            <button class="remove-tag" onclick="removeTag('${tag}')">&times;</button>
        `;
        container.appendChild(tagElement);
    });
}

// These functions are no longer needed with the new filter design

// Get filtered restaurants based on current filters
function getFilteredRestaurants() {
    const minRating = parseFloat(document.getElementById('rating-filter').value) || 0;
    const sortedRestaurants = window.currentSortedRestaurants || restaurants;
    
    return sortedRestaurants.filter(restaurant => {
        let show = true;
        
        // Filter by selected tags (must have ALL selected tags - includes reviewers)
        if (selectedTags.size > 0) {
            const hasAllSelectedTags = Array.from(selectedTags).every(selectedTag => {
                const standardizedSelectedTag = standardizeTag(selectedTag);
                
                // Check if it matches a regular tag (already standardized)
                const matchesTag = restaurant.tags.some(restaurantTag => 
                    restaurantTag === standardizedSelectedTag
                );
                // Or check if it matches the reviewer (already standardized)
                const matchesReviewer = restaurant.reviewer === standardizedSelectedTag;
                // Or check if it matches location data (only city name)
                const matchesLocation = restaurant.locationData && 
                                      restaurant.locationData.cityStandardized === standardizedSelectedTag;
                
                return matchesTag || matchesReviewer || matchesLocation;
            });
            if (!hasAllSelectedTags) show = false;
        }
        
        // Filter by rating
        if (restaurant.rating < minRating) show = false;
        
        return show;
    });
}

// Apply filters with pagination
function applyFilters(skipUrlUpdate = false) {
    // Reset to first page when filters change (but not during navigation)
    if (!skipUrlUpdate) {
        currentPage = 1;
        updateUrl();
    }
    
    // Get filtered restaurants
    const filteredRestaurants = getFilteredRestaurants();
    
    // Update map markers visibility
    restaurants.forEach((restaurant, index) => {
        const marker = markers[index];
        const isFiltered = filteredRestaurants.includes(restaurant);
        
        if (isFiltered) {
            if (!map.hasLayer(marker)) {
                map.addLayer(marker);
            }
        } else {
            if (map.hasLayer(marker)) {
                map.removeLayer(marker);
            }
        }
    });
    
    // Display paginated filtered restaurants
    displayPaginatedRestaurants(filteredRestaurants);
    
    // Update global map visibility and highlighting
    updateGlobalMap();
}

// Clear all filters
function clearAllFilters() {
    // Clear selected tags
    selectedTags.clear();
    updateSelectedTagsDisplay();
    
    // Clear tag search input
    document.getElementById('tag-search').value = '';
    document.getElementById('tag-suggestions').classList.add('hidden');
    
    // Reset rating slider to minimum value
    const ratingSlider = document.getElementById('rating-filter');
    const ratingValueDisplay = document.getElementById('rating-value');
    ratingSlider.value = ratingSlider.min;
    ratingValueDisplay.textContent = `${ratingSlider.min}+`;
    
    // Reset sort to default
    currentSort = 'newest';
    document.getElementById('sort-filter').value = 'newest';
    
    // Reset pagination
    currentPage = 1;
    updateUrl();
    
    // Re-sort and display all restaurants
    sortAndDisplayRestaurants();
}

// Center map to show all restaurants with appropriate bounding box
function centerMapOnCenterOfMass() {
    if (restaurants.length === 0) return;
    
    // Find bounding box of all restaurant locations
    let minLat = Infinity;
    let maxLat = -Infinity;
    let minLng = Infinity;
    let maxLng = -Infinity;
    let count = 0;
    
    restaurants.forEach(restaurant => {
        if (restaurant.latitude && restaurant.longitude) {
            minLat = Math.min(minLat, restaurant.latitude);
            maxLat = Math.max(maxLat, restaurant.latitude);
            minLng = Math.min(minLng, restaurant.longitude);
            maxLng = Math.max(maxLng, restaurant.longitude);
            count++;
        }
    });
    
    if (count > 0) {
        // Create bounding box with some padding
        const bounds = [
            [minLat, minLng],
            [maxLat, maxLng]
        ];
        
        // Fit map to show all restaurants with padding
        map.fitBounds(bounds, {
            padding: [20, 20], // Add 20px padding on all sides
            maxZoom: 12 // Don't zoom in too close even if restaurants are clustered
        });
        
    } else {
        // Fallback to NYC if no valid coordinates
        map.setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
    }
}

// Center map on first filtered result with city-level zoom
function centerMapOnFirstResult() {
    const filteredRestaurants = getFilteredRestaurants();
    
    if (filteredRestaurants.length === 0) {
        // Fallback to showing all restaurants if no filtered results
        centerMapOnCenterOfMass();
        return;
    }
    
    const firstRestaurant = filteredRestaurants[0];
    if (firstRestaurant.latitude && firstRestaurant.longitude) {
        // Center on first result with city-level zoom (zoom 10-11 shows city + surrounding areas)
        map.setView([firstRestaurant.latitude, firstRestaurant.longitude], 11);
    } else {
        // Fallback to NYC if no valid coordinates
        map.setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
    }
}

// Center map on all restaurants (fallback function)
function centerMapOnRestaurants() {
    if (restaurants.length === 0) return;
    
    const group = new L.featureGroup(markers);
    map.fitBounds(group.getBounds().pad(0.1));
}

// Tab Navigation Setup
function setupTabNavigation() {
    const tabBtns = document.querySelectorAll('.tab-btn');
    
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });
    
    // Set up restaurant form if suggest tab exists
    setupRestaurantForm();
    setupSocialMediaValidation();
}

function switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
    });
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('hidden', content.id !== `${tabName}-tab`);
    });
    
    // Load required scripts if switching to suggest tab
    if (tabName === 'suggest') {
        setupPlaceSearch();
        loadRecaptcha();
    }
}

function loadRecaptcha() {
    // Check if reCAPTCHA script is already loaded
    if (window.grecaptcha) {
        document.getElementById('recaptcha-container').style.display = 'block';
        return;
    }
    
    // Load reCAPTCHA script
    const script = document.createElement('script');
    script.src = 'https://www.google.com/recaptcha/api.js';
    script.async = true;
    script.defer = true;
    script.onload = () => {
        document.getElementById('recaptcha-container').style.display = 'block';
    };
    document.head.appendChild(script);
}

// OpenStreetMap Place Search Setup
function setupPlaceSearch() {
    const searchInput = document.getElementById('restaurantSearch');
    const searchResults = document.getElementById('searchResults');
    
    if (!searchInput || !searchResults) return;
    
    let searchTimeout;
    
    // Setup search input event listener
    searchInput.addEventListener('input', function(e) {
        const query = e.target.value.trim();
        const clearBtn = document.getElementById('clearSearchBtn');
        
        // Show/hide clear button based on content
        if (clearBtn) {
            if (query.length > 0) {
                clearBtn.classList.remove('hidden');
            } else {
                clearBtn.classList.add('hidden');
            }
        }
        
        // Clear previous timeout
        clearTimeout(searchTimeout);
        
        if (query.length < 3) {
            hideSearchResults();
            return;
        }
        
        // Optimized debounce for faster response
        searchTimeout = setTimeout(() => {
            searchPlaces(query);
        }, 200); // Reduced from 300ms to 200ms for faster response
    });
    
    // Hide results when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            hideSearchResults();
        }
    });
    
    // Setup social media functionality
    setupSocialMediaForm();
}

// Setup social media platform and username functionality
function setupSocialMediaForm() {
    const platformSelect = document.getElementById('socialPlatform');
    const usernameInput = document.getElementById('socialUsername');
    const usernamePrefix = document.getElementById('usernamePrefix');
    const hiddenUrlInput = document.getElementById('socialMediaUrl');
    
    if (!platformSelect || !usernameInput || !usernamePrefix || !hiddenUrlInput) return;
    
    // Platform selection handler
    platformSelect.addEventListener('change', function() {
        updateUsernamePrefix();
        generateSocialMediaUrl();
    });
    
    // Username input handler
    usernameInput.addEventListener('input', function() {
        generateSocialMediaUrl();
        validateSocialMediaForm();
    });
    
    function updateUsernamePrefix() {
        const platform = platformSelect.value;
        
        switch(platform) {
            case 'instagram':
                usernamePrefix.textContent = '@';
                usernamePrefix.classList.remove('hidden');
                usernameInput.placeholder = 'username';
                usernameInput.disabled = false;
                break;
            case 'tiktok':
                usernamePrefix.textContent = '@';
                usernamePrefix.classList.remove('hidden');
                usernameInput.placeholder = 'username';
                usernameInput.disabled = false;
                break;
            case 'youtube':
                usernamePrefix.textContent = '@';
                usernamePrefix.classList.remove('hidden');
                usernameInput.placeholder = 'channelname';
                usernameInput.disabled = false;
                break;
            default:
                usernamePrefix.classList.add('hidden');
                usernameInput.placeholder = '';
                usernameInput.disabled = true;
                usernameInput.value = '';
        }
    }
    
    function generateSocialMediaUrl() {
        const platform = platformSelect.value;
        const username = usernameInput.value.trim();
        
        if (!platform || !username) {
            hiddenUrlInput.value = '';
            return;
        }
        
        let url = '';
        const cleanUsername = username.replace(/^[@]/, ''); // Remove @ if user typed it
        
        switch(platform) {
            case 'instagram':
                url = `https://instagram.com/${cleanUsername}`;
                break;
            case 'tiktok':
                url = `https://tiktok.com/@${cleanUsername}`;
                break;
            case 'youtube':
                // Handle both @handle and channel formats
                if (cleanUsername.startsWith('@') || !cleanUsername.includes('/')) {
                    url = `https://youtube.com/@${cleanUsername}`;
                } else {
                    url = `https://youtube.com/${cleanUsername}`;
                }
                break;
        }
        
        hiddenUrlInput.value = url;
    }
    
    function validateSocialMediaForm() {
        const platform = platformSelect.value;
        const username = usernameInput.value.trim();
        const url = hiddenUrlInput.value;
        
        // Remove previous validation classes
        platformSelect.classList.remove('valid', 'invalid');
        usernameInput.classList.remove('valid', 'invalid');
        
        if (platform && username && url) {
            if (validateSocialMediaUrl(url)) {
                platformSelect.classList.add('valid');
                usernameInput.classList.add('valid');
            } else {
                usernameInput.classList.add('invalid');
            }
        }
    }
    
    // Initialize prefix state
    updateUsernamePrefix();
}

// Convert Photon API response format to Nominatim-compatible format
function convertPhotonToNominatim(feature) {
    const props = feature.properties || {};
    const coords = feature.geometry?.coordinates || [0, 0];
    
    // Build address components
    const address = {
        house_number: props.housenumber || '',
        road: props.street || '',
        city: props.city || '',
        state: props.state || '',
        postcode: props.postcode || '',
        country: props.country || 'United States',
        country_code: 'us'
    };
    
    // Build display name
    const nameParts = [
        props.name,
        props.housenumber,
        props.street,
        props.city,
        props.state,
        props.postcode,
        'United States'
    ].filter(Boolean);
    
    return {
        place_id: feature.properties.osm_id || Math.random(),
        lat: coords[1]?.toString() || '0',
        lon: coords[0]?.toString() || '0', 
        display_name: nameParts.join(', '),
        type: props.osm_value || 'restaurant',
        class: props.osm_key || 'amenity',
        category: 'amenity',
        address: address,
        extratags: {
            amenity: props.osm_value || 'restaurant',
            name: props.name || ''
        }
    };
}

// Minimal search query variations for maximum speed
function prepareSearchQueries(originalQuery) {
    const queries = [];
    const query = originalQuery.trim().toLowerCase();
    
    // 1. Always try original query first
    queries.push(originalQuery);
    
    // 2. Only ONE fallback: add "restaurant" if query is short and doesn't contain restaurant words
    if (query.length <= 20 && !query.includes('restaurant') && !query.includes('cafe') && !query.includes('bar')) {
        queries.push(`${originalQuery} restaurant`);
    }
    
    return queries.slice(0, 2); // Maximum 2 queries for speed
}

// Remove duplicate search results
function removeDuplicateResults(results) {
    const seen = new Set();
    return results.filter(place => {
        const key = `${place.display_name}-${place.lat}-${place.lon}`;
        if (seen.has(key)) {
            return false;
        }
        seen.add(key);
        return true;
    });
}

async function searchPlaces(query) {
    const searchResults = document.getElementById('searchResults');
    
    try {
        // Show loading state
        searchResults.innerHTML = '<div class="search-loading">Searching...</div>';
        searchResults.classList.remove('hidden');
        
        // Prepare multiple search variations for better results
        const searchQueries = prepareSearchQueries(query);
        let allResults = [];
        
        // Try each search variation with timeout protection
        for (const searchQuery of searchQueries) {
            try {
                // Add timeout to prevent hanging requests
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                const response = await fetch(
                    `https://photon.komoot.io/api/?` + new URLSearchParams({
                        q: searchQuery,
                        limit: '5',
                        osm_tag: 'amenity:restaurant,amenity:cafe,amenity:fast_food,amenity:bar,amenity:pub'
                    }), {
                        headers: {
                            'User-Agent': 'BiggerBellyBoys/1.0'
                        },
                        signal: controller.signal
                    }
                );
                
                clearTimeout(timeoutId);
            
                if (response.ok) {
                    const data = await response.json();
                    // Photon returns {features: [...]} format, convert to Nominatim-like format
                    const results = data.features ? data.features.map(convertPhotonToNominatim) : [];
                    allResults = allResults.concat(results);
                    
                    // AGGRESSIVE: Exit immediately after first successful result set
                    if (results.length > 0) break; // Stop as soon as we get ANY results
                }
            } catch (error) {
                // Skip failed/timeout requests and continue to next query
                console.log(`Search query "${searchQuery}" failed or timed out:`, error.message);
                continue;
            }
            
            // Reduced delay for better responsiveness
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        // Remove duplicates based on display_name and coordinates
        const uniqueResults = removeDuplicateResults(allResults);
        
        // Photon API already filters for restaurants, so minimal additional filtering needed
        const restaurantResults = uniqueResults.filter(place => {
            // Just verify we have basic required fields
            return place.display_name && place.lat && place.lon;
        });
        
        displaySearchResults(restaurantResults.slice(0, 8)); // Show more results since they're pre-filtered
        
    } catch (error) {
        console.error('Search error:', error);
        searchResults.innerHTML = '<div class="search-no-results">Search failed. Please try again.</div>';
    }
}

function displaySearchResults(results) {
    const searchResults = document.getElementById('searchResults');
    
    if (results.length === 0) {
        searchResults.innerHTML = '<div class="search-no-results">No restaurants found. Try a different search term.</div>';
        return;
    }
    
    const resultsHTML = results.map(place => {
        const name = extractPlaceName(place);
        const address = place.display_name || '';
        const type = getPlaceType(place);
        
        return `
            <div class="search-result-item" onclick="selectPlace(${JSON.stringify(place).replace(/"/g, '&quot;')})">
                <div class="search-result-name">${escapeHtml(name)}</div>
                <div class="search-result-address">${escapeHtml(address)}</div>
                ${type ? `<div class="search-result-type">${escapeHtml(type)}</div>` : ''}
            </div>
        `;
    }).join('');
    
    searchResults.innerHTML = resultsHTML;
}

function extractPlaceName(place) {
    // Try to get a clean restaurant name from the display_name
    if (place.name) {
        return place.name;
    }
    
    // Fallback: extract first part of display_name before first comma
    const displayName = place.display_name || '';
    const firstPart = displayName.split(',')[0];
    return firstPart || 'Unknown Restaurant';
}

function getPlaceType(place) {
    const type = place.type || '';
    const amenity = place.extratags?.amenity || '';
    
    if (amenity) return amenity.replace('_', ' ');
    if (type) return type.replace('_', ' ');
    return '';
}

function selectPlace(place) {
    console.log('Place selected:', place);
    
    
    // Extract address components
    const address = place.display_name || '';
    const name = extractPlaceName(place);
    
    // Populate form fields
    document.getElementById('restaurantName').value = name;
    document.getElementById('address').value = address;
    document.getElementById('latitude').value = place.lat || '';
    document.getElementById('longitude').value = place.lon || '';
    
    // Clear search and hide results
    document.getElementById('restaurantSearch').value = name;
    hideSearchResults();
    
    // Show clear button since we now have content
    const clearBtn = document.getElementById('clearSearchBtn');
    if (clearBtn) {
        clearBtn.classList.remove('hidden');
    }
    
    // Validate form
    validateForm();
}

function hideSearchResults() {
    const searchResults = document.getElementById('searchResults');
    if (searchResults) {
        searchResults.classList.add('hidden');
    }
}

function clearRestaurantSearch() {
    // Clear search input
    const searchInput = document.getElementById('restaurantSearch');
    if (searchInput) {
        searchInput.value = '';
    }
    
    
    // Clear auto-populated fields
    document.getElementById('restaurantName').value = '';
    document.getElementById('address').value = '';
    document.getElementById('latitude').value = '';
    document.getElementById('longitude').value = '';
    
    // Hide search results and clear button
    hideSearchResults();
    const clearBtn = document.getElementById('clearSearchBtn');
    if (clearBtn) {
        clearBtn.classList.add('hidden');
    }
    
    // Validate form (will likely show required field errors)
    validateForm();
    
    // Focus back to search input
    if (searchInput) {
        searchInput.focus();
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}


function validateForm() {
    const requiredFields = ['restaurantName', 'address', 'submitterName', 'socialPlatform', 'socialUsername'];
    let allValid = true;
    let errors = [];
    
    // Check required fields
    requiredFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (!field || !field.value.trim()) {
            allValid = false;
            const fieldName = field ? field.labels[0].textContent.replace(' *', '') : fieldId;
            errors.push(`${fieldName} is required`);
        }
    });
    
    
    // Validate social media URL with regex
    const socialMediaUrl = document.getElementById('socialMediaUrl').value.trim();
    if (socialMediaUrl && !validateSocialMediaUrl(socialMediaUrl)) {
        allValid = false;
        errors.push('Please provide a valid Instagram, TikTok, or YouTube profile URL');
    }
    
    // Update submit button state
    const submitBtn = document.getElementById('submitBtn');
    if (submitBtn) {
        submitBtn.disabled = !allValid;
    }
    
    // Show validation errors (optional)
    if (errors.length > 0) {
        console.log('Validation errors:', errors);
    }
    
    return allValid;
}

function validateSocialMediaUrl(url) {
    // Only allow Instagram, TikTok, and YouTube
    const patterns = {
        instagram: /^https?:\/\/(www\.)?instagram\.com\/[a-zA-Z0-9._]+\/?$/,
        tiktok: /^https?:\/\/(www\.)?tiktok\.com\/@[a-zA-Z0-9._]+\/?$/,
        youtube: /^https?:\/\/(www\.)?youtube\.com\/(channel\/[a-zA-Z0-9_-]+|c\/[a-zA-Z0-9_-]+|user\/[a-zA-Z0-9_-]+|@[a-zA-Z0-9._-]+)\/?$/
    };
    
    // Check if URL matches any of the allowed patterns
    return Object.values(patterns).some(pattern => pattern.test(url));
}

function setupSocialMediaValidation() {
    const socialMediaInput = document.getElementById('socialMediaUrl');
    if (!socialMediaInput) return;
    
    // Add real-time validation
    socialMediaInput.addEventListener('input', function(e) {
        const url = e.target.value.trim();
        const field = e.target;
        
        // Remove previous validation classes
        field.classList.remove('valid', 'invalid');
        
        if (url) {
            if (validateSocialMediaUrl(url)) {
                field.classList.add('valid');
            } else {
                field.classList.add('invalid');
            }
        }
        
        // Revalidate form
        validateForm();
    });
}

// Restaurant Form Setup
function setupRestaurantForm() {
    const form = document.getElementById('restaurantForm');
    if (!form) return;
    
    const WORKER_URL = 'https://restaurant-form-handler.vlad-trofimov.workers.dev';
    
    form.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const submitBtn = document.getElementById('submitBtn');
        const result = document.getElementById('result');
        
        // Disable button and show loading
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';
        result.style.display = 'none';
        
        try {
            // Validate form before submission
            if (!validateForm()) {
                throw new Error('Please fill in all required fields correctly');
            }
            
            // Ensure social media URL is generated
            const platformSelect = document.getElementById('socialPlatform');
            const usernameInput = document.getElementById('socialUsername');
            if (platformSelect && usernameInput && platformSelect.value && usernameInput.value) {
                // Trigger URL generation one more time to be safe
                const event = new Event('input', { bubbles: true });
                usernameInput.dispatchEvent(event);
            }
            
            // Get form data
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            // Get reCAPTCHA token
            if (window.grecaptcha) {
                const recaptchaResponse = grecaptcha.getResponse();
                if (!recaptchaResponse) {
                    throw new Error('Please complete the reCAPTCHA verification');
                }
                data.recaptchaToken = recaptchaResponse;
            } else {
                throw new Error('reCAPTCHA not loaded. Please try again.');
            }
            
            // Remove empty honeypot field if present
            delete data.website;
            
            console.log('Submitting restaurant suggestion:', data);
            
            // Submit to worker
            const response = await fetch(WORKER_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            console.log('Response status:', response.status);
            const responseData = await response.json();
            console.log('Response data:', responseData);
            
            if (responseData.success) {
                result.className = 'result success';
                result.textContent = responseData.message || 'Restaurant submitted successfully! Thank you for your suggestion.';
                e.target.reset(); // Clear form
                if (window.grecaptcha) {
                    grecaptcha.reset(); // Reset reCAPTCHA
                }
            } else {
                throw new Error(responseData.error || 'Submission failed');
            }
            
        } catch (error) {
            console.error('Submission error:', error);
            result.className = 'result error';
            result.textContent = 'Error: ' + error.message;
        }
        
        // Re-enable button and show result
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Restaurant Suggestion';
        result.style.display = 'block';
    });
}

// Debug function to show tab navigation (remove after testing)
function showTabs() {
    const tabNav = document.querySelector('.tab-navigation');
    if (tabNav) {
        tabNav.style.display = 'flex';
        console.log('‚úÖ Tab navigation is now visible');
    } else {
        console.log('‚ùå Tab navigation not found');
    }
}

// Function to show the suggest form (called by header button)
function showSuggestForm() {
    // Hide restaurants content and show suggest form
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.add('hidden');
        suggestTab.classList.remove('hidden');
        
        // Load required scripts for the form
        setupPlaceSearch();
        loadRecaptcha();
        
        // Scroll to top of form
        suggestTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        // Update URL to include suggest parameter
        updateUrl();
        
        console.log('‚úÖ Opened restaurant suggestion form');
    }
}

// Function to show suggest form from URL (no scrolling)
function showSuggestFormFromUrl() {
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.add('hidden');
        suggestTab.classList.remove('hidden');
        
        // Load required scripts for the form
        setupPlaceSearch();
        loadRecaptcha();
        
        console.log('‚úÖ Showed restaurant suggestion form from URL');
    }
}

// Function to hide the suggest form and return to restaurants
function hideSuggestForm() {
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.remove('hidden');
        suggestTab.classList.add('hidden');
        
        // Update URL to remove suggest parameter
        updateUrl();
        
        console.log('‚úÖ Closed restaurant suggestion form');
    }
}

// Function to hide suggest form from URL navigation (no URL update)
function hideSuggestFormFromUrl() {
    const restaurantsTab = document.getElementById('restaurants-tab');
    const suggestTab = document.getElementById('suggest-tab');
    
    if (restaurantsTab && suggestTab) {
        restaurantsTab.classList.remove('hidden');
        suggestTab.classList.add('hidden');
        
        console.log('‚úÖ Returned to restaurants view');
    }
}

// Debug function to switch to suggest tab (keep for console access)
function showSuggestTab() {
    showSuggestForm();
}

// Global Food Tour Map functionality using Leaflet
let globalMapInstance = null;

function initializeGlobalMap() {
    const worldMapContainer = document.getElementById('world-map');
    if (!worldMapContainer || globalMapInstance) {
        console.log('üö´ Cannot initialize global map:', !worldMapContainer ? 'container not found' : 'already initialized');
        return;
    }
    
    console.log('üó∫Ô∏è Initializing global map with Leaflet...');
    
    try {
        // Initialize Leaflet map for world view
        globalMapInstance = L.map('world-map', {
            center: [20, 0], // Center on world
            zoom: 2,
            maxZoom: 6,
            minZoom: 1,
            zoomControl: true,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            dragging: true
        });

        // Add world tile layer
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OSM',
            subdomains: 'abcd',
            maxZoom: 6
        }).addTo(globalMapInstance);
        
        // Load country boundaries
        loadCountryBoundaries();
        
        console.log('‚úÖ Global map initialized successfully');
        
    } catch (error) {
        console.warn('Leaflet global map failed to initialize, falling back to simple map:', error);
        initializeSimpleMap();
    }
}

// Country coordinates for markers (approximate capitals/centers)
const countryCoordinates = {
    'ethiopia': [9.1450, 40.4897],
    'poland': [51.9194, 19.1451], 
    'cuba': [21.5218, -77.7812],
    'yemen': [15.552727, 48.516388],
    'bangladesh': [23.6850, 90.3563],
    'afghanistan': [33.9391, 67.7100],
    'philippines': [12.8797, 121.7740],
    'colombia': [4.5709, -74.2973],
    'eritrea': [15.7394, 38.9916],
    'united states': [39.8283, -98.5795],
    'usa': [39.8283, -98.5795],
    'mexico': [23.6345, -102.5528],
    'canada': [56.1304, -106.3468],
    'brazil': [-14.2350, -51.9253],
    'russia': [61.5240, 105.3188],
    'china': [35.8617, 104.1954],
    'india': [20.5937, 78.9629],
    'australia': [-25.2744, 133.7751],
    'france': [46.6034, 1.8883],
    'germany': [51.1657, 10.4515],
    'united kingdom': [55.3781, -3.4360],
    'uk': [55.3781, -3.4360],
    'south africa': [-30.5595, 22.9375]
};

// Store country layers for highlighting
let countryLayers = {};
let visitedCountryLayers = [];

function loadCountryBoundaries() {
    console.log('üó∫Ô∏è Loading country boundaries...');
    
    // Use a simple GeoJSON source for country boundaries
    fetch('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson')
        .then(response => response.json())
        .then(data => {
            console.log('‚úÖ Country boundaries loaded');
            
            // Add each country as a layer
            L.geoJSON(data, {
                style: {
                    fillColor: '#f0f0f0',
                    weight: 1,
                    opacity: 0.8,
                    color: 'white',
                    fillOpacity: 0.3
                },
                onEachFeature: (feature, layer) => {
                    const countryName = feature.properties.name;
                    if (countryName) {
                        // Store layer by country name (lowercased)
                        const countryKey = countryName.toLowerCase();
                        countryLayers[countryKey] = layer;
                        
                        // Also store by common variations
                        if (countryKey === 'united states of america') {
                            countryLayers['united states'] = layer;
                            countryLayers['usa'] = layer;
                        }
                        if (countryKey === 'united kingdom') {
                            countryLayers['uk'] = layer;
                        }
                        
                        layer.bindPopup(`<strong>${countryName}</strong>`);
                    }
                }
            }).addTo(globalMapInstance);
            
        })
        .catch(error => {
            console.warn('‚ùå Failed to load country boundaries:', error);
            // Fallback to markers if GeoJSON fails
            console.log('üîÑ Falling back to marker approach');
        });
}

function highlightVisitedCountries(visitedCountries) {
    if (!globalMapInstance) return;
    
    console.log('üó∫Ô∏è Highlighting visited countries:', visitedCountries);
    
    // Reset all previously highlighted countries
    visitedCountryLayers.forEach(layer => {
        layer.setStyle({
            fillColor: '#f0f0f0',
            fillOpacity: 0.3
        });
    });
    visitedCountryLayers = [];
    
    // Country name mapping
    const countryNames = {
        'ethiopia': 'Ethiopia',
        'poland': 'Poland', 
        'cuba': 'Cuba',
        'yemen': 'Yemen',
        'bangladesh': 'Bangladesh',
        'afghanistan': 'Afghanistan',
        'philippines': 'Philippines',
        'colombia': 'Colombia',
        'eritrea': 'Eritrea',
        'united states': 'United States',
        'usa': 'United States',
        'mexico': 'Mexico',
        'canada': 'Canada',
        'brazil': 'Brazil',
        'russia': 'Russia',
        'china': 'China',
        'india': 'India',
        'australia': 'Australia',
        'france': 'France',
        'germany': 'Germany',
        'united kingdom': 'United Kingdom',
        'uk': 'United Kingdom',
        'south africa': 'South Africa'
    };
    
    // Highlight visited countries
    visitedCountries.forEach(countryTag => {
        const layer = countryLayers[countryTag];
        if (layer) {
            layer.setStyle({
                fillColor: '#d4651a', // Your primary color
                fillOpacity: 0.7
            });
            
            // Update popup to show it's visited
            const countryDisplayName = countryNames[countryTag] || countryTag;
            layer.bindPopup(`<strong>${countryDisplayName}</strong><br><span style="color: #d4651a;">‚úì Global Belly Food Tour</span>`);
            
            visitedCountryLayers.push(layer);
        }
    });
}

function initializeSimpleMap() {
    // Fallback simple map if jVectorMap fails
    const worldMapContainer = document.getElementById('world-map');
    if (!worldMapContainer) return;
    
    console.log('üó∫Ô∏è Initializing simple fallback map');
    
    // Get visited countries for the fallback
    const filteredRestaurants = getFilteredRestaurants();
    const visitedCountries = new Set();
    
    filteredRestaurants.forEach(restaurant => {
        restaurant.tags.forEach(tag => {
            const standardizedTag = standardizeTag(tag);
            if (standardizedTag !== 'global belly food tour' && 
                standardizedTag !== 'nyc' && 
                standardizedTag !== 'ny' &&
                standardizedTag !== 'new york') {
                
                // Country names for display
                const countryNames = {
                    'ethiopia': 'Ethiopia',
                    'poland': 'Poland', 
                    'cuba': 'Cuba',
                    'yemen': 'Yemen',
                    'bangladesh': 'Bangladesh',
                    'afghanistan': 'Afghanistan',
                    'philippines': 'Philippines',
                    'colombia': 'Colombia',
                    'eritrea': 'Eritrea'
                };
                
                if (countryNames[standardizedTag]) {
                    visitedCountries.add(countryNames[standardizedTag]);
                }
            }
        });
    });
    
    const countryList = Array.from(visitedCountries).join(', ');
    
    worldMapContainer.innerHTML = `
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 300px; background: #f8f9fa; border-radius: 8px; color: #666; padding: 2rem;">
            <div style="text-align: center;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üåç</div>
                <div style="font-size: 1.25rem; margin-bottom: 1rem; color: var(--primary-color);">Countries Visited</div>
                <div style="font-size: 1rem; line-height: 1.6; max-width: 400px;">
                    ${countryList || 'No countries found'}
                </div>
                <div style="font-size: 0.8rem; margin-top: 1.5rem; opacity: 0.7;">
                    Interactive world map unavailable
                </div>
            </div>
        </div>`;
}

function updateGlobalMap() {
    const globalMapContainer = document.getElementById('global-map');
    if (!globalMapContainer) {
        console.log('‚ùå Global map container not found');
        return;
    }
    
    // Check if "global belly food tour" is selected
    const hasGlobalTourTag = Array.from(selectedTags).some(tag => 
        standardizeTag(tag) === 'global belly food tour'
    );
    
    console.log('üîç Global tour tag selected:', hasGlobalTourTag);
    console.log('üìã Selected tags:', Array.from(selectedTags));
    
    if (hasGlobalTourTag) {
        // Show global map
        console.log('‚úÖ Showing global map container');
        globalMapContainer.classList.remove('hidden');
        
        // Initialize map if not already done
        if (!globalMapInstance) {
            initializeGlobalMap();
        }
        
        // Get filtered restaurants and extract country tags
        const filteredRestaurants = getFilteredRestaurants();
        const visitedCountries = new Set();
        
        filteredRestaurants.forEach(restaurant => {
            restaurant.tags.forEach(tag => {
                const standardizedTag = standardizeTag(tag);
                // Skip the tour tag itself and common location tags
                if (standardizedTag !== 'global belly food tour' && 
                    standardizedTag !== 'nyc' && 
                    standardizedTag !== 'ny' &&
                    standardizedTag !== 'new york') {
                    
                    // Check if this tag matches a known country
                    if (countryCoordinates[standardizedTag]) {
                        visitedCountries.add(standardizedTag);
                    }
                }
            });
        });
        
        // Highlight visited countries
        if (globalMapInstance && Object.keys(countryLayers).length > 0) {
            highlightVisitedCountries(Array.from(visitedCountries));
        }
        
    } else {
        // Hide global map
        globalMapContainer.classList.add('hidden');
    }
}